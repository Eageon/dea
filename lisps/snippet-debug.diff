1c1
< ;;; Yasnippet.el --- Yet another snippet extension for Emacs.
---
> ;;; yasnippet.el --- Yet another snippet extension for Emacs.
3,9c3,7
< ;; Copyright 2008 pluskid
< ;;           2009 pluskid, joaotavora
< 
< ;; Authors: pluskid <pluskid@gmail.com>, joaotavora <joaotavora@gmail.com>
< ;; Version: 0.6.1
< ;; Package-version: 0.6.1c
< ;; X-URL: http://code.google.com/p/yasnippet/
---
> ;; Copyright (C) 2008-2012 Free Software Foundation, Inc.
> ;; Authors: pluskid <pluskid@gmail.com>,  João Távora <joaotavora@gmail.com>
> ;; Version: 0.8.0
> ;; Package-version: 0.8.0
> ;; X-URL: http://github.com/capitaomorte/yasnippet
11c9
< ;; URL: http://code.google.com/p/yasnippet/
---
> ;; URL: http://github.com/capitaomorte/yasnippet
14c12
< ;; This file is free software; you can redistribute it and/or modify
---
> ;; This program is free software: you can redistribute it and/or modify
16,17c14,15
< ;; the Free Software Foundation; either version 2, or (at your option)
< ;; any later version.
---
> ;; the Free Software Foundation, either version 3 of the License, or
> ;; (at your option) any later version.
19c17
< ;; This file is distributed in the hope that it will be useful,
---
> ;; This program is distributed in the hope that it will be useful,
25,27c23
< ;; along with GNU Emacs; see the file COPYING.  If not, write to
< ;; the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
< ;; Boston, MA 02111-1307, USA.
---
> ;; along with this program.  If not, see <http://www.gnu.org/licenses/>.
30,31d25
< 
< ;; Basic steps to setup:
33,43c27,32
< ;;   1. In your .emacs file:
< ;;        (add-to-list 'load-path "/dir/to/yasnippet.el")
< ;;        (require 'yasnippet)
< ;;   2. Place the `snippets' directory somewhere.  E.g: ~/.emacs.d/snippets
< ;;   3. In your .emacs file
< ;;        (setq yas/root-directory "~/.emacs/snippets")
< ;;        (yas/load-directory yas/root-directory)
< ;;   4. To enable the YASnippet menu and tab-trigger expansion
< ;;        M-x yas/minor-mode
< ;;   5. To globally enable the minor mode in *all* buffers
< ;;        M-x yas/global-mode
---
> ;;   Basic steps to setup:
> ;;
> ;;    (add-to-list 'load-path
> ;;                 "~/path-to-yasnippet")
> ;;    (require 'yasnippet)
> ;;    (yas-global-mode 1)
45,46d33
< ;;   Steps 4. and 5. are optional, you don't have to use the minor
< ;;   mode to use YASnippet.
50c37
< ;;       `yas/root-directory'
---
> ;;       `yas-snippet-dirs'
53,56c40,45
< ;;           stored. Can also be a list of directories that
< ;;           `yas/reload-all' will use for bulk-reloading snippets. In
< ;;           that case the first directory the default for storing new
< ;;           snippets.
---
> ;;           stored. Can also be a list of directories. In that case,
> ;;           when used for bulk (re)loading of snippets (at startup or
> ;;           via `yas-reload-all'), directories appearing earlier in
> ;;           the list shadow other dir's snippets. Also, the first
> ;;           directory is taken as the default for storing the user's
> ;;           new snippets.
58c47,50
< ;;       `yas/mode-symbol'
---
> ;;           The deprecated `yas/root-directory' aliases this variable
> ;;           for backward-compatibility.
> ;;
> ;;       `yas-extra-modes'
63c55
< ;;           `yas/root-directory' and is used for deciding which
---
> ;;           `yas-snippet-dirs' and is used for deciding which
65a58,60
> ;;           Deprecated `yas/mode-symbol' aliases this variable for
> ;;           backward-compatibility.
> ;;
68c63
< ;;       M-x yas/expand
---
> ;;       M-x yas-expand
70,71c65,66
< ;;           Try to expand snippets before point.  In `yas/minor-mode',
< ;;           this is bound to `yas/trigger-key' which you can customize.
---
> ;;           Try to expand snippets before point.  In `yas-minor-mode',
> ;;           this is bound to `yas-trigger-key' which you can customize.
73c68
< ;;       M-x yas/load-directory
---
> ;;       M-x yas-load-directory
77c72
< ;;       M-x yas/insert-snippet
---
> ;;       M-x yas-insert-snippet
84,91c79
< ;;       M-x yas/find-snippets
< ;;
< ;;           Lets you find the snippet files in the correct
< ;;           subdirectory of `yas/root-directory', according to the
< ;;           active major mode (if it exists) like
< ;;           `find-file-other-window'.
< ;;
< ;;       M-x yas/visit-snippet-file
---
> ;;       M-x yas-visit-snippet-file
94c82
< ;;           `yas/insert-snippet', but instead of expanding it, takes
---
> ;;           `yas-insert-snippet', but instead of expanding it, takes
98c86
< ;;       M-x yas/new-snippet
---
> ;;       M-x yas-new-snippet
101c89
< ;;           subdirectory of `yas/root-directory', according to the
---
> ;;           subdirectory of `yas-snippet-dirs', according to the
104c92
< ;;       M-x yas/load-snippet-buffer
---
> ;;       M-x yas-load-snippet-buffer
110c98
< ;;       M-x yas/tryout-snippet
---
> ;;       M-x yas-tryout-snippet
116a105,111
> ;;       M-x yas-describe-tables
> ;;
> ;;           Lists known snippets in a separate buffer. User is
> ;;           prompted as to whether only the currently active tables
> ;;           are to be displayed, or all the tables for all major
> ;;           modes.
> ;;
122,124c117,119
< ;;       (setq yas/prompt-functions '(yas/dropdown-prompt
< ;;                                    yas/ido-prompt
< ;;                                    yas/completing-prompt))
---
> ;;       (setq yas-prompt-functions '(yas-dropdown-prompt
> ;;                                    yas-ido-prompt
> ;;                                    yas-completing-prompt))
131c126
< ;;   `yas/root-directory' or `yas/global-mode', make sure the path to
---
> ;;   `yas-snippet-dirs' or `yas-global-mode', make sure the path to
136c131
< ;;      http://code.google.com/p/yasnippet/
---
> ;;      http://github.com/capitaomorte/yasnippet
141d135
< (require 'assoc)
142a137
> (require 'help-mode)
145,147c140
< ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
< ;; User customizable variables
< 
---
> ;;; User customizable variables
153,155c146,147
< ;;;###autoload
< (defcustom yas/root-directory nil
<   "Root directory that stores the snippets for each major mode.
---
> (defvar yas--load-file-name load-file-name
>   "Store the filename that yasnippet.el was originally loaded from.")
157,161c149,160
< If you set this from your .emacs, can also be a list of strings,
< for multiple root directories. If you make this a list, the first
< element is always the user-created snippets directory. Other
< directories are used for bulk reloading of all snippets using
< `yas/reload-all'"
---
> (defcustom yas-snippet-dirs (remove nil
>                                     (list "~/.emacs.d/snippets"
>                                           (when yas--load-file-name
>                                             (concat (file-name-directory yas--load-file-name) "snippets"))))
>   "Directory or list of snippet dirs for each major mode.
> 
> The directory where user-created snippets are to be stored. Can
> also be a list of directories. In that case, when used for
> bulk (re)loading of snippets (at startup or via
> `yas-reload-all'), directories appearing earlier in the list
> shadow other dir's snippets. Also, the first directory is taken
> as the default for storing the user's new snippets."
170c169
<              (unless (or (not (fboundp 'yas/reload-all))
---
>              (unless (or (not (fboundp 'yas-reload-all))
172c171
<                (yas/reload-all)))))
---
>                (yas-reload-all)))))
174,178c173,183
< (defcustom yas/prompt-functions '(yas/x-prompt
<                                   yas/dropdown-prompt
<                                   yas/completing-prompt
<                                   yas/ido-prompt
<                                   yas/no-prompt)
---
> (defun yas-snippet-dirs ()
>   "Returns `yas-snippet-dirs' (which see) as a list."
>   (if (listp yas-snippet-dirs) yas-snippet-dirs (list yas-snippet-dirs)))
> 
> (defvaralias 'yas/root-directory 'yas-snippet-dirs)
> 
> (defcustom yas-prompt-functions '(yas-x-prompt
>                                   yas-dropdown-prompt
>                                   yas-completing-prompt
>                                   yas-ido-prompt
>                                   yas-no-prompt)
205c210
< (defcustom yas/indent-line 'auto
---
> (defcustom yas-indent-line 'auto
222c227
< (defcustom yas/also-auto-indent-first-line nil
---
> (defcustom yas-also-auto-indent-first-line nil
225c230
< Naturally this is only valid when `yas/indent-line' is `auto'"
---
> Naturally this is only valid when `yas-indent-line' is `auto'"
229c234
< (defcustom yas/snippet-revival t
---
> (defcustom yas-snippet-revival t
234,235c239,240
< (defcustom yas/trigger-key "TAB"
<   "The key bound to `yas/expand' when function `yas/minor-mode' is active.
---
> (defcustom yas-trigger-key "<tab>"
>   "The key bound to `yas-expand' when `yas-minor-mode' is active.
246,250c251,255
<              ;; `yas/trigger-key' is *not* loaded.
<              (if (fboundp 'yas/trigger-key-reload)
<                  (yas/trigger-key-reload old)))))
<   
< (defcustom yas/next-field-key '("TAB" "<tab>")
---
>              ;; `yas-trigger-key' is *not* loaded.
>              (if (fboundp 'yas--trigger-key-reload)
>                  (yas--trigger-key-reload old)))))
> 
> (defcustom yas-next-field-key '("TAB" "<tab>")
262,264c267,269
<            (if (fboundp 'yas/init-yas-in-snippet-keymap)
<                (yas/init-yas-in-snippet-keymap))))
<            
---
>            (if (fboundp 'yas--init-yas-in-snippet-keymap)
>                (yas--init-yas-in-snippet-keymap))))
> 
266c271
< (defcustom yas/prev-field-key '("<backtab>" "<S-tab>")
---
> (defcustom yas-prev-field-key '("<backtab>" "<S-tab>")
278,279c283,284
<            (if (fboundp 'yas/init-yas-in-snippet-keymap)
<                (yas/init-yas-in-snippet-keymap))))
---
>            (if (fboundp 'yas--init-yas-in-snippet-keymap)
>                (yas--init-yas-in-snippet-keymap))))
281c286
< (defcustom yas/skip-and-clear-key "C-d"
---
> (defcustom yas-skip-and-clear-key '("C-d" "<delete>" "<deletechar>")
293,294c298,299
<            (if (fboundp 'yas/init-yas-in-snippet-keymap)
<                (yas/init-yas-in-snippet-keymap))))
---
>            (if (fboundp 'yas--init-yas-in-snippet-keymap)
>                (yas--init-yas-in-snippet-keymap))))
296,297c301,302
< (defcustom yas/triggers-in-field nil
<   "If non-nil, `yas/next-field-key' can trigger stacked expansions.
---
> (defcustom yas-triggers-in-field nil
>   "If non-nil, `yas-next-field-key' can trigger stacked expansions.
299c304
< Otherwise, `yas/next-field-key' just tries to move on to the next
---
> Otherwise, `yas-next-field-key' just tries to move on to the next
304,305c309,310
< (defcustom yas/fallback-behavior 'call-other-command
<   "How to act when `yas/trigger-key' does *not* expand a snippet.
---
> (defcustom yas-fallback-behavior 'call-other-command
>   "How to act when `yas-trigger-key' does *not* expand a snippet.
308c313
<     and call the next command bound to `yas/trigger-key'.
---
>     and call the next command bound to `yas-trigger-key'.
311c316
<   `yas/expand-returns' nil)
---
>   `yas-expand' returns nil)
319d323
< (make-variable-buffer-local 'yas/fallback-behavior)
321c325
< (defcustom yas/choose-keys-first nil
---
> (defcustom yas-choose-keys-first nil
326c330
< This affects `yas/insert-snippet' and `yas/visit-snippet-file'."
---
> This affects `yas-insert-snippet' and `yas-visit-snippet-file'."
330c334
< (defcustom yas/choose-tables-first nil
---
> (defcustom yas-choose-tables-first nil
336c340
< This affects `yas/insert-snippet', `yas/visit-snippet-file'"
---
> This affects `yas-insert-snippet', `yas-visit-snippet-file'"
340c344
< (defcustom yas/use-menu 'real-modes
---
> (defcustom yas-use-menu 'abbreviate
346,348d349
< - If set to `real-modes' only submenus whose name more or less
< corresponds to a major mode are listed.
< 
350c351,356
< menu and the modes set in `yas/mode-symbol' are listed.
---
> menu and the modes set in `yas-extra-modes' are listed.
> 
> - If set to `full', every submenu is listed
> 
> - It set to nil, don't display a menu at all (this requires a
>   `yas-reload-all' call if the menu is already visible).
353,355c359,361
<   :type '(choice (const :tag "Full"  t)
<                  (const :tag "Real modes only" real-modes)
<                  (const :tag "Abbreviate" abbreviate))
---
>   :type '(choice (const :tag "Full"  full)
>                  (const :tag "Abbreviate" abbreviate)
>                  (const :tag "No menu" nil))
358c364,366
< (defcustom yas/trigger-symbol " =>"
---
> (defcustom yas-trigger-symbol (if (eq window-system 'mac)
>                                   (char-to-string ?\x21E5) ;; little ->| sign
>                                   " =>")
363c371
< (defcustom yas/wrap-around-region nil
---
> (defcustom yas-wrap-around-region nil
371c379
< (defcustom yas/good-grace t
---
> (defcustom yas-good-grace t
378,379c386,387
< (defcustom yas/ignore-filenames-as-triggers nil
<   "If non-nil, don't derive tab triggers from filenames.
---
> (defcustom yas-visit-from-menu nil
>   "If non-nil visit snippets's files from menu, instead of expanding them.
381,382c389
< This means a snippet without a \"# key:'\ directive wont have a
< tab trigger."
---
> This cafn only work when snippets are loaded from files."
386,387c393,394
< (defcustom yas/visit-from-menu nil
<   "If non-nil visit snippets's files from menu, instead of expanding them.
---
> (defcustom yas-expand-only-for-last-commands nil
>   "List of `last-command' values to restrict tab-triggering to, or nil.
389,390c396,404
< This cafn only work when snippets are loaded from files."
<   :type 'boolean
---
> Leave this set at nil (the default) to be able to trigger an
> expansion simply by placing the cursor after a valid tab trigger,
> using whichever commands.
> 
> Optionallly, set this to something like '(self-insert-command) if
> you to wish restrict expansion to only happen when the last
> letter of the snippet tab trigger was typed immediately before
> the trigger key itself."
>   :type '(repeat function)
393,395c407,410
< (defface yas/field-highlight-face
<   '((((class color) (background light)) (:background "DarkSeaGreen1"))
<     (t (:background "DimGrey")))
---
> ;; Only two faces, and one of them shouldn't even be used...
> ;;
> (defface yas-field-highlight-face
>   '((t (:inherit 'region)))
399c414
< (defface yas/field-debug-face
---
> (defface yas--field-debug-face
405,407c420,422
< ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
< ;; User can also customize the next defvars
< (defun yas/define-some-keys (keys keymap definition)
---
> ;;; User can also customize the next defvars
> 
> (defun yas--define-some-keys (keys keymap definition)
414,422c429,440
< (defvar yas/keymap
<   (let ((map (make-sparse-keymap)))
<     (mapc #'(lambda (binding)
<               (yas/define-some-keys (car binding) map (cdr binding)))
<           `((,yas/next-field-key     . yas/next-field-or-maybe-expand)
<             (,yas/prev-field-key     . yas/prev-field)
<             ("C-g"                   . yas/abort-snippet)
<             (,yas/skip-and-clear-key . yas/skip-and-clear-or-delete-char)))
<     map)
---
> (defun yas--init-yas-in-snippet-keymap ()
>   (setq yas-keymap
>         (let ((map (make-sparse-keymap)))
>           (mapc #'(lambda (binding)
>                     (yas--define-some-keys (car binding) map (cdr binding)))
>                 `((,yas-next-field-key     . yas-next-field-or-maybe-expand)
>                   (,yas-prev-field-key     . yas-prev-field)
>                   ("C-g"                   . yas-abort-snippet)
>                   (,yas-skip-and-clear-key . yas-skip-and-clear-or-delete-char)))
>           map)))
> 
> (defvar yas-keymap (yas--init-yas-in-snippet-keymap)
425,428c443,450
< (defvar yas/key-syntaxes (list "w" "w_" "w_." "^ ")
<   "A list of syntax of a key. This list is tried in the order
< to try to find a key. For example, if the list is '(\"w\" \"w_\").
< And in emacs-lisp-mode, where \"-\" has the syntax of \"_\":
---
> (defvar yas-key-syntaxes (list "w" "w_" "w_." "w_.()" "^ ")
>   "List of character syntaxes used to find a trigger key before point.
> The list is tried in the order while scanning characters
> backwards from point. For example, if the list is '(\"w\" \"w_\")
> first look for trigger keys which are composed exclusively of
> \"word\"-syntax characters, and then, if that fails, look for
> keys which are either of \"word\" or \"symbol\"
> syntax. Triggering after
432c454,456
< will first try \"bar\", if not found, then \"foo-bar\" is tried.")
---
> will, according to the \"w\" element first try \"bar\". If that
> isn't a trigger key, \"foo-bar\" is tried, respecting a second
> \"w_\" element.")
434c458
< (defvar yas/after-exit-snippet-hook
---
> (defvar yas-after-exit-snippet-hook
441c465
< `yas/snippet-beg' : The beginning of the region of the snippet.
---
> `yas-snippet-beg' : The beginning of the region of the snippet.
443c467
< `yas/snippet-end' : Similar to beg.
---
> `yas-snippet-end' : Similar to beg.
447c471
< (defvar yas/before-expand-snippet-hook
---
> (defvar yas-before-expand-snippet-hook
451,458c475,478
< (defvar yas/buffer-local-condition
<   '(if (and (not (bobp))
<             (or (equal 'font-lock-comment-face
<                        (get-char-property (1- (point))
<                                           'face))
<                 (equal 'font-lock-string-face
<                        (get-char-property (1- (point))
<                                           'face))))
---
> (defvar yas-buffer-local-condition
>   '(if (and (or (fourth (syntax-ppss))
>                 (fifth (syntax-ppss)))
>             (eq (symbol-function this-command) 'yas-expand-from-trigger-key))
463c483,484
< This variable is a lisp form:
---
> This variable is a lisp form which is evaluated everytime a
> snippet expansion is attemped:
492c513
<          evaluate to non-nil, are considered for expansion. 
---
>          evaluate to non-nil, are considered for expansion.
503c524
<               (setq yas/buffer-local-condition
---
>               (setq yas-buffer-local-condition
512d532
< (make-variable-buffer-local 'yas/buffer-local-condition)
515,516c535
< ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
< ;; Internal variables
---
> ;;; Internal variables
518c537
< (defvar yas/version "0.6.1b")
---
> (defvar yas--version "0.8.0 (beta)")
520c539
< (defvar yas/menu-table (make-hash-table)
---
> (defvar yas--menu-table (make-hash-table)
523,526c542
< (defvar yas/active-keybindings nil
<   "A list of cons (KEYMAP . KEY) setup from defining snippets.")
< 
< (defvar yas/known-modes
---
> (defvar yas--known-modes
530,531c546,547
< (defvar yas/escaped-characters
<   '(?\\ ?` ?' ?$ ?} )
---
> (defvar yas--escaped-characters
>   '(?\\ ?` ?\" ?' ?$ ?} ?{ ?\( ?\))
534c550
< (defconst yas/field-regexp
---
> (defconst yas--field-regexp
538c554
< (defconst yas/multi-dollar-lisp-expression-regexp
---
> (defconst yas--multi-dollar-lisp-expression-regexp
542c558
< (defconst yas/backquote-lisp-expression-regexp
---
> (defconst yas--backquote-lisp-expression-regexp
546c562
< (defconst yas/transform-mirror-regexp
---
> (defconst yas--transform-mirror-regexp
550c566
< (defconst yas/simple-mirror-regexp
---
> (defconst yas--simple-mirror-regexp
554c570
< (defvar yas/snippet-id-seed 0
---
> (defvar yas--snippet-id-seed 0
557,559c573,575
< (defun yas/snippet-next-id ()
<   (let ((id yas/snippet-id-seed))
<     (incf yas/snippet-id-seed)
---
> (defun yas--snippet-next-id ()
>   (let ((id yas--snippet-id-seed))
>     (incf yas--snippet-id-seed)
563,564c579
< ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
< ;; Minor mode stuff
---
> ;;; Minor mode stuff
569c584
< (defvar yas/minor-mode-menu nil
---
> (defvar yas--minor-mode-menu nil
572c587
< (defun yas/init-minor-keymap ()
---
> (defun yas--init-minor-keymap ()
574c589,590
<     (easy-menu-define yas/minor-mode-menu
---
>     (when yas-use-menu
>       (easy-menu-define yas--minor-mode-menu
576c592
<       "Menu used when YAS/minor-mode is active."
---
>       "Menu used when `yas-minor-mode' is active."
579c595
<         ["Expand trigger" yas/expand
---
>         ["Expand trigger" yas-expand
581c597
<         ["Insert at point..." yas/insert-snippet
---
>         ["Insert at point..." yas-insert-snippet
583c599
<         ["New snippet..." yas/new-snippet
---
>         ["New snippet..." yas-new-snippet
585c601
<         ["Visit snippet file..." yas/visit-snippet-file
---
>         ["Visit snippet file..." yas-visit-snippet-file
587,588d602
<         ["Find snippets..." yas/find-snippets
<          :help "Invoke `find-file' in the appropriate snippet directory"] 
591c605
<          ["Visit snippets" (setq yas/visit-from-menu t)
---
>          ["Visit snippets" (setq yas-visit-from-menu t)
593,594c607,608
<           :active t :style radio   :selected yas/visit-from-menu]
<          ["Expand snippets" (setq yas/visit-from-menu nil)
---
>           :active t :style radio   :selected yas-visit-from-menu]
>          ["Expand snippets" (setq yas-visit-from-menu nil)
596c610
<           :active t :style radio :selected (not yas/visit-from-menu)]
---
>           :active t :style radio :selected (not yas-visit-from-menu)]
598,601c612
<          ["Show \"Real\" modes only" (setq yas/use-menu 'real-modes)
<           :help "Show snippet submenus for modes that appear to be real major modes"
<           :active t :style radio   :selected (eq yas/use-menu 'real-modes)]
<          ["Show all modes" (setq yas/use-menu 't)
---
>          ["Show all known modes" (setq yas-use-menu 'full)
603,604c614,615
<           :active t :style radio   :selected (eq yas/use-menu 't)]
<          ["Abbreviate according to current mode" (setq yas/use-menu 'abbreviate)
---
>           :active t :style radio   :selected (eq yas-use-menu 'full)]
>          ["Abbreviate according to current mode" (setq yas-use-menu 'abbreviate)
606c617
<           :active t :style radio   :selected (eq yas/use-menu 'abbreviate)])
---
>           :active t :style radio   :selected (eq yas-use-menu 'abbreviate)])
608c619
<          ["Auto" (setq yas/indent-line 'auto)
---
>          ["Auto" (setq yas-indent-line 'auto)
610,611c621,622
<           :active t :style radio   :selected (eq yas/indent-line 'auto)]
<          ["Fixed" (setq yas/indent-line 'fixed)
---
>           :active t :style radio   :selected (eq yas-indent-line 'auto)]
>          ["Fixed" (setq yas-indent-line 'fixed)
613,614c624,625
<           :active t :style radio   :selected (eq yas/indent-line 'fixed)]
<          ["None" (setq yas/indent-line 'none)
---
>           :active t :style radio   :selected (eq yas-indent-line 'fixed)]
>          ["None" (setq yas-indent-line 'none)
616c627
<           :active t :style radio   :selected (not (member yas/indent-line '(fixed auto)))]
---
>           :active t :style radio   :selected (not (member yas-indent-line '(fixed auto)))]
618,619c629,630
<          ["Also auto indent first line" (setq yas/also-auto-indent-first-line
<                                               (not yas/also-auto-indent-first-line))
---
>          ["Also auto indent first line" (setq yas-also-auto-indent-first-line
>                                               (not yas-also-auto-indent-first-line))
621,622c632,633
<           :active (eq yas/indent-line 'auto)
<           :style toggle :selected yas/also-auto-indent-first-line]
---
>           :active (eq yas-indent-line 'auto)
>           :style toggle :selected yas-also-auto-indent-first-line]
625,628c636,639
<          ["System X-widget" (setq yas/prompt-functions
<                                   (cons 'yas/x-prompt
<                                         (remove 'yas/x-prompt
<                                                 yas/prompt-functions)))
---
>          ["System X-widget" (setq yas-prompt-functions
>                                   (cons 'yas-x-prompt
>                                         (remove 'yas-x-prompt
>                                                 yas-prompt-functions)))
630,635c641,646
<           :active t :style radio   :selected (eq (car yas/prompt-functions)
<                                                  'yas/x-prompt)]
<          ["Dropdown-list" (setq yas/prompt-functions
<                                 (cons 'yas/dropdown-prompt
<                                       (remove 'yas/dropdown-prompt
<                                               yas/prompt-functions)))
---
>           :active t :style radio   :selected (eq (car yas-prompt-functions)
>                                                  'yas-x-prompt)]
>          ["Dropdown-list" (setq yas-prompt-functions
>                                 (cons 'yas-dropdown-prompt
>                                       (remove 'yas-dropdown-prompt
>                                               yas-prompt-functions)))
637,642c648,653
<           :active t :style radio   :selected (eq (car yas/prompt-functions)
<                                                  'yas/dropdown-prompt)]
<          ["Ido" (setq yas/prompt-functions
<                       (cons 'yas/ido-prompt
<                             (remove 'yas/ido-prompt
<                                     yas/prompt-functions)))
---
>           :active t :style radio   :selected (eq (car yas-prompt-functions)
>                                                  'yas-dropdown-prompt)]
>          ["Ido" (setq yas-prompt-functions
>                       (cons 'yas-ido-prompt
>                             (remove 'yas-ido-prompt
>                                     yas-prompt-functions)))
644,649c655,660
<           :active t :style radio   :selected (eq (car yas/prompt-functions)
<                                                  'yas/ido-prompt)]
<          ["Completing read" (setq yas/prompt-functions
<                                   (cons 'yas/completing-prompt
<                                         (remove 'yas/completing-prompt-prompt
<                                                 yas/prompt-functions)))
---
>           :active t :style radio   :selected (eq (car yas-prompt-functions)
>                                                  'yas-ido-prompt)]
>          ["Completing read" (setq yas-prompt-functions
>                                   (cons 'yas-completing-prompt
>                                         (remove 'yas-completing-prompt
>                                                 yas-prompt-functions)))
651,652c662,663
<           :active t :style radio   :selected (eq (car yas/prompt-functions)
<                                                  'yas/completing-prompt-prompt)]
---
>           :active t :style radio   :selected (eq (car yas-prompt-functions)
>                                                  'yas-completing-prompt)]
655,657c666,668
<          ["Wrap region in exit marker" 
<           (setq yas/wrap-around-region
<                 (not yas/wrap-around-region))
---
>          ["Wrap region in exit marker"
>           (setq yas-wrap-around-region
>                 (not yas-wrap-around-region))
659,662c670,673
<           :style toggle :selected yas/wrap-around-region]
<          ["Allow stacked expansions " 
<           (setq yas/triggers-in-field
<                 (not yas/triggers-in-field))
---
>           :style toggle :selected yas-wrap-around-region]
>          ["Allow stacked expansions "
>           (setq yas-triggers-in-field
>                 (not yas-triggers-in-field))
664,667c675,678
<           :style toggle :selected yas/triggers-in-field]
<          ["Revive snippets on undo " 
<           (setq yas/snippet-revival
<                 (not yas/snippet-revival))
---
>           :style toggle :selected yas-triggers-in-field]
>          ["Revive snippets on undo "
>           (setq yas-snippet-revival
>                 (not yas-snippet-revival))
669,672c680,683
<           :style toggle :selected yas/snippet-revival]
<          ["Good grace " 
<           (setq yas/good-grace
<                 (not yas/good-grace))
---
>           :style toggle :selected yas-snippet-revival]
>          ["Good grace "
>           (setq yas-good-grace
>                 (not yas-good-grace))
674,679c685
<           :style toggle :selected yas/good-grace]
<          ["Ignore filenames as triggers" 
<           (setq yas/ignore-filenames-as-triggers
<                 (not yas/ignore-filenames-as-triggers))
<           :help "If non-nil don't derive tab triggers from filenames"
<           :style toggle :selected yas/ignore-filenames-as-triggers]
---
>           :style toggle :selected yas-good-grace]
682c688
<         ["Load snippets..."  yas/load-directory
---
>         ["Load snippets..."  yas-load-directory
684c690
<         ["Reload everything" yas/reload-all
---
>         ["Reload everything" yas-reload-all
686,687c692,694
<         ["About"            yas/about
<          :help "Display some information about YASsnippet"]))
---
>         ["About"            yas-about
>          :help "Display some information about YASsnippet"])))
> 
690,693c697,699
<     (define-key map "\C-c&\C-s" 'yas/insert-snippet)
<     (define-key map "\C-c&\C-n" 'yas/new-snippet)
<     (define-key map "\C-c&\C-v" 'yas/visit-snippet-file)
<     (define-key map "\C-c&\C-f" 'yas/find-snippets)
---
>     (define-key map "\C-c&\C-s" 'yas-insert-snippet)
>     (define-key map "\C-c&\C-n" 'yas-new-snippet)
>     (define-key map "\C-c&\C-v" 'yas-visit-snippet-file)
696,697c702,703
< (defvar yas/minor-mode-map (yas/init-minor-keymap)
<   "The keymap used when `yas/minor-mode' is active.")
---
> (defvar yas-minor-mode-map (yas--init-minor-keymap)
>   "The keymap used when `yas-minor-mode' is active.")
699,700c705,706
< (defun yas/trigger-key-reload (&optional unbind-key)
<   "Rebind `yas/expand' to the new value of `yas/trigger-key'.
---
> (defun yas--trigger-key-reload (&optional unbind-key)
>   "Rebind `yas-expand' to the new value of `yas-trigger-key'.
703c709
< `yas/minor-mode-map'."
---
> `yas-minor-mode-map'."
707,711c713,771
<     (define-key yas/minor-mode-map (read-kbd-macro unbind-key) nil)) 
<   (when  (and yas/trigger-key
<               (stringp yas/trigger-key)
<               (not (string= yas/trigger-key "")))
<     (define-key yas/minor-mode-map (read-kbd-macro yas/trigger-key) 'yas/expand)))
---
>     (define-key yas-minor-mode-map (read-kbd-macro unbind-key) nil))
>   (when  (and yas-trigger-key
>               (stringp yas-trigger-key)
>               (not (string= yas-trigger-key "")))
>     (define-key yas-minor-mode-map (read-kbd-macro yas-trigger-key) 'yas-expand)))
> 
> (defvar yas--tables (make-hash-table)
>   "A hash table of mode symbols to `yas--table' objects.")
> 
> (defvar yas--parents (make-hash-table)
>   "A hash table of mode symbols do lists of direct parent mode symbols.
> 
> This list is populated when reading the \".yas-parents\" files
> found when traversing snippet directories with
> `yas-load-directory'.
> 
> There might be additionalal parenting information stored in the
> `derived-mode-parent' property of some mode symbols, but that is
> not recorded here.")
> 
> (defvar yas--direct-keymaps (list)
>   "Keymap alist supporting direct snippet keybindings.
> 
> This variable is is placed in `emulation-mode-map-alists'.
> 
> Its elements looks like (TABLE-NAME . KEYMAP). They're
> instantiated on `yas-reload-all' but KEYMAP is added to only when
> loading snippets. `yas--direct-TABLE-NAME' is then a variable set
> buffer-locally when entering `yas-minor-mode'. KEYMAP binds all
> defined direct keybindings to the command
> `yas-expand-from-keymap' which then which snippet to expand.")
> 
> (defun yas-direct-keymaps-reload ()
>   "Force reload the direct keybinding for active snippet tables."
>   (interactive)
>   (setq yas--direct-keymaps nil)
>   (maphash #'(lambda (name table)
>                (push (cons (intern (format "yas--direct-%s" name))
>                            (yas--table-direct-keymap table))
>                      yas--direct-keymaps))
>            yas--tables))
> 
> (defun yas--modes-to-activate ()
>   "Compute list of mode symbols that are active for `yas-expand'
> and friends."
>   (let ((modes-to-activate (list major-mode))
>         (mode major-mode))
>     (while (setq mode (get mode 'derived-mode-parent))
>       (push mode modes-to-activate))
>     (dolist (mode (yas-extra-modes))
>       (push mode modes-to-activate))
>     (remove-duplicates
>      (append modes-to-activate
>              (mapcan #'(lambda (mode)
>                          (yas--all-parents mode))
>                      modes-to-activate)))))
> 
> (defvar yas-minor-mode-hook nil
>   "Hook run when yas-minor-mode is turned on")
714c774
< (define-minor-mode yas/minor-mode
---
> (define-minor-mode yas-minor-mode
717,718c777,778
< When YASnippet mode is enabled, the `tas/trigger-key' key expands
< snippets of code depending on the mode.
---
> When YASnippet mode is enabled, the `yas-trigger-key' key expands
> snippets of code depending on the major mode.
724c784
< You can customize the key through `yas/trigger-key'.
---
> You can customize the key through `yas-trigger-key'.
727c787
< \\{yas/minor-mode-map}"
---
> \\{yas-minor-mode-map}"
732,743c792,818
<   (when yas/minor-mode
<     (yas/trigger-key-reload)
<     ;; load all snippets definitions unless we still don't have a
<     ;; root-directory or some snippets have already been loaded.
<     (unless (or (null yas/root-directory)
<                 (> (hash-table-count yas/snippet-tables) 0))
<       (yas/reload-all))))
< 
< (defvar yas/dont-activate #'(lambda ()
<                               (and yas/root-directory
<                                    (null (yas/get-snippet-tables))))
<   "If non-nil don't let `yas/minor-mode-on' active yas for this buffer.
---
>   (cond (yas-minor-mode
>          ;; Reload the trigger key
>          ;;
>          (yas--trigger-key-reload)
>          ;; Install the direct keymaps in `emulation-mode-map-alists'
>          ;; (we use `add-hook' even though it's not technically a hook,
>          ;; but it works). Then define variables named after modes to
>          ;; index `yas--direct-keymaps'.
>          ;;
>          ;; Also install the post-command-hook.
>          ;;
>          (add-hook 'emulation-mode-map-alists 'yas--direct-keymaps)
>          (add-hook 'post-command-hook 'yas--post-command-handler nil t)
>          ;; Set the `yas--direct-%s' vars for direct keymap expansion
>          ;;
>          (dolist (mode (yas--modes-to-activate))
>            (let ((name (intern (format "yas--direct-%s" mode))))
>              (set-default name nil)
>              (set (make-local-variable name) t)))
>          ;; Perform JIT loads
>          ;;
>          (yas--load-pending-jits))
>         (t
>          ;; Uninstall the direct keymaps and the post-command hook
>          ;;
>          (remove-hook 'post-command-hook 'yas--post-command-handler t)
>          (remove-hook 'emulation-mode-map-alists 'yas--direct-keymaps))))
745,748c820,821
< `yas/minor-mode-on' is usually called by `yas/global-mode' so
< this effectively lets you define exceptions to the \"global\"
< behaviour.")
< (make-variable-buffer-local 'yas/dont-activate)
---
> (defvar yas--dont-activate '(minibufferp)
>   "If non-nil don't let `yas-minor-mode-on' active yas for this buffer.
749a823
> If a function, then its result is used.
751,752c825,826
< (defun yas/minor-mode-on ()
<   "Turn on YASnippet minor mode.
---
> If a list of functions, then all functions must return nil to
> activate yas for this buffer.
754,761c828,834
< Do this unless `yas/dont-activate' is t or the function
< `yas/get-snippet-tables' (which see), returns an empty list."
<   (interactive)
<   (unless (or (and (functionp yas/dont-activate)
<                    (funcall yas/dont-activate))
<               (and (not (functionp yas/dont-activate))
<                    yas/dont-activate))
<     (yas/minor-mode 1)))
---
> `yas-minor-mode-on' is usually called by `yas-global-mode' so
> this effectively lets you define exceptions to the \"global\"
> behaviour. Can also be a function of zero arguments.")
> (make-variable-buffer-local 'yas--dont-activate)
> 
> (defun yas-minor-mode-on ()
>   "Turn on YASnippet minor mode.
763,764c836
< (defun yas/minor-mode-off ()
<   "Turn off YASnippet minor mode."
---
> Do this unless `yas--dont-activate' is truish "
766c838,846
<   (yas/minor-mode -1))
---
>   (unless (cond ((functionp yas--dont-activate)
>                  (funcall yas--dont-activate))
>                 ((consp yas--dont-activate)
>                  (some #'funcall yas--dont-activate))
>                 (yas--dont-activate))
>     ;; Load all snippets definitions unless we still don't have a
>     ;; root-directory or some snippets have already been loaded.
>     ;;
>     (yas-minor-mode 1)))
768c848,849
< (define-globalized-minor-mode yas/global-mode yas/minor-mode yas/minor-mode-on
---
> ;;;###autoload
> (define-globalized-minor-mode yas-global-mode yas-minor-mode yas-minor-mode-on
771a853,857
> (defun yas--global-mode-reload-with-jit-maybe ()
>   (when yas-global-mode (yas-reload-all)))
> 
> (add-hook 'yas-global-mode-hook 'yas--global-mode-reload-with-jit-maybe)
> 
775c861
< (defvar yas/font-lock-keywords
---
> (defvar yas--font-lock-keywords
792c878
< (defun yas/init-major-keymap ()
---
> (defun yas--init-major-keymap ()
803,804c889,890
<                      (list "Load this snippet" 'yas/load-snippet-buffer "\C-c\C-c")
<                      (list "Try out this snippet" 'yas/tryout-snippet "\C-c\C-t")))))
---
>                      (list "Load this snippet" 'yas-load-snippet-buffer "\C-c\C-c")
>                      (list "Try out this snippet" 'yas-tryout-snippet "\C-c\C-t")))))
808c894
<   (yas/init-major-keymap)
---
>   (yas--init-major-keymap)
814,815c900
<   (set-syntax-table (standard-syntax-table))
<   (setq font-lock-defaults '(yas/font-lock-keywords))
---
>   (setq font-lock-defaults '(yas--font-lock-keywords))
817c902,903
<   (use-local-map snippet-mode-map))
---
>   (set (make-local-variable 'comment-start) "#")
>   (set (make-local-variable 'comment-start-skip) "#+[\t ]*"))
819,820d904
< ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
< ;; Internal structs for template management
822,823c906,909
< (defstruct (yas/template (:constructor yas/make-template
<                                        (content name condition expand-env file keybinding)))
---
> 
> ;;; Internal structs for template management
> 
> (defstruct (yas--template (:constructor yas--make-blank-template))
824a911
>   key
830c917,934
<   keybinding)
---
>   keybinding
>   uuid
>   menu-binding-pair
>   group      ;; as dictated by the #group: directive or .yas-make-groups
>   perm-group ;; as dictated by `yas-define-menu'
>   table
>   )
> 
> (defun yas--populate-template (template &rest args)
>   "Helper function to populate a template with properties"
>   (let (p v)
>     (while args
>       (aset template
>             (position (intern (substring (symbol-name (car args)) 1))
>                       (mapcar #'car (get 'yas--template 'cl-struct-slots)))
>             (second args))
>       (setq args (cddr args)))
>     template))
832,835c936
< (defvar yas/snippet-tables (make-hash-table)
<   "A hash table of MAJOR-MODE symbols to `yas/snippet-table' objects.")
< 
< (defstruct (yas/snippet-table (:constructor yas/make-snippet-table (name)))
---
> (defstruct (yas--table (:constructor yas--make-snippet-table (name)))
840c941,945
< `yas/snippet-table-name'
---
> `yas--table-name'
> 
>   A symbol name normally corresponding to a major mode, but can
>   also be a pseudo major-mode to be referenced in
>   `yas-extra-modes', for example.
842,844c947
<   A symbol normally corresponding to a major mode, but can also be
<   a pseudo major-mode to be referenced in `yas/mode-symbol', for
<   example.
---
> `yas--table-hash'
846c949,953
< `yas/snippet-table-hash'
---
>   A hash table (KEY . NAMEHASH), known as the \"keyhash\". KEY is
>   a string or a vector, where the former is the snippet's trigger
>   and the latter means it's a direct keybinding. NAMEHASH is yet
>   another hash of (NAME . TEMPLATE) where NAME is the snippet's
>   name and TEMPLATE is a `yas--template' object.
848,850c955
<   A hash table the key is a string (the snippet key) and the
<   value is yet another hash of (NAME TEMPLATE), where NAME is the
<   snippet name and TEMPLATE is a `yas/template' object name.
---
> `yas--table-direct-keymap'
852c957,960
< `yas/snippet-table-parents'
---
>   A keymap for the snippets in this table that have direct
>   keybindings. This is kept in sync with the keyhash, i.e., all
>   the elements of the keyhash that are vectors appear here as
>   bindings to `yas-expand-from-keymap'.
854,855c962,966
<   A list of tables considered parents of this table: i.e. when
<   searching for expansions they are searched as well."
---
> `yas--table-uuidhash'
> 
>   A hash table mapping snippets uuid's to the same `yas--template'
>   objects. A snippet uuid defaults to the snippet's name.
> "
858c969,1054
<   (parents nil))
---
>   (uuidhash (make-hash-table :test 'equal))
>   (parents nil)
>   (direct-keymap (make-sparse-keymap)))
> 
> (defun yas--get-template-by-uuid (mode uuid)
>   "Find the snippet template in MODE by its UUID."
>   (let* ((table (gethash mode yas--tables mode)))
>     (when table
>       (gethash uuid (yas--table-uuidhash table)))))
> 
> ;; Apropos storing/updating in TABLE, this works in two steps:
> ;;
> ;; 1. `yas--remove-template-by-uuid' removes any
> ;;    keyhash-namehash-template mappings from TABLE, grabing the
> ;;    snippet by its uuid. Also removes mappings from TABLE's
> ;;    `yas--table-direct-keymap' (FIXME: and should probably take care
> ;;    of potentially stale menu bindings right?.)
> ;;
> ;; 2. `yas--add-template' adds this all over again.
> ;;
> ;;    Create a new or add to an existing keyhash-namehash mapping.
> ;;
> ;;  For reference on understanding this, consider three snippet
> ;;  definitions:
> ;;
> ;;  A:   # name: The Foo
> ;;       # key: foo
> ;;       # binding: C-c M-l
> ;;
> ;;  B:   # name: Mrs Foo
> ;;       # key: foo
> ;;
> ;;  C:   # name: The Bar
> ;;       # binding: C-c M-l
> ;;
> ;;  D:   # name: Baz
> ;;       # key: baz
> ;;
> ;;  keyhash       namehashes(3)      yas--template structs(4)
> ;;  -----------------------------------------------------
> ;;                                            __________
> ;;                                           /          \
> ;;  "foo"      --->  "The Foo" --->  [yas--template A]   |
> ;;                   "Mrs Foo" --->  [yas--template B]   |
> ;;                                                      |
> ;;  [C-c M-l]  --->  "The Foo" -------------------------/
> ;;                   "The Bar" --->  [yas--template C]
> ;;
> ;;  "baz"      --->  "Baz"     --->  [yas--template D]
> ;;
> ;; Additionally, since uuid defaults to the name, we have a
> ;; `yas--table-uuidhash' for TABLE
> ;;
> ;; uuidhash       yas--template structs
> ;; -------------------------------
> ;; "The Foo" ---> [yas--template A]
> ;; "Mrs Foo" ---> [yas--template B]
> ;; "The Bar" ---> [yas--template C]
> ;; "Baz"     ---> [yas--template D]
> ;;
> ;; FIXME: the more I look at this data-structure the more I think I'm
> ;; stupid. There has to be an easier way (but beware lots of code
> ;; depends on this).
> ;;
> (defun yas--remove-template-by-uuid (table uuid)
>   "Remove from TABLE a template identified by UUID."
>   (let ((template (gethash uuid (yas--table-uuidhash table))))
>     (when template
>       (let* ((name                (yas--template-name template))
>              (empty-keys          nil))
>         ;; Remove the name from each of the targeted namehashes
>         ;;
>         (maphash #'(lambda (k v)
>                      (let ((template (gethash name v)))
>                        (when (and template
>                                   (eq uuid (yas--template-uuid template)))
>                          (remhash name v)
>                          (when (zerop (hash-table-count v))
>                            (push k empty-keys)))))
>                  (yas--table-hash table))
>         ;; Remove the namehash themselves if they've become empty
>         ;;
>         (dolist (key empty-keys)
>           (when (vectorp key)
>             (define-key (yas--table-direct-keymap table) key nil))
>           (remhash key (yas--table-hash table)))
860,861c1056,1083
< (defvar yas/better-guess-for-replacements nil
<   "If non-nil `yas/store' better guess snippet replacements.")
---
>         ;; Finally, remove the uuid from the uuidhash
>         ;;
>         (remhash uuid (yas--table-uuidhash table))))))
> 
> (defun yas--add-template (table template)
>   "Store in TABLE the snippet template TEMPLATE.
> 
> KEY can be a string (trigger key) of a vector (direct
> keybinding)."
>   (let ((name (yas--template-name template))
>         (key (yas--template-key template))
>         (keybinding (yas--template-keybinding template))
>         (menu-binding-pair (yas--template-menu-binding-pair-get-create template)))
>     (dolist (k (remove nil (list key keybinding)))
>       (puthash name
>                template
>                (or (gethash k
>                             (yas--table-hash table))
>                    (puthash k
>                             (make-hash-table :test 'equal)
>                             (yas--table-hash table))))
>       (when (vectorp k)
>         (define-key (yas--table-direct-keymap table) k 'yas-expand-from-keymap)))
> 
>     ;; Update TABLE's `yas--table-uuidhash'
>     (puthash (yas--template-uuid template)
>              template
>              (yas--table-uuidhash table))))
863,864c1085,1098
< (defun yas/store (table name key template)
<   "Store a snippet template in the TABLE."
---
> (defun yas--update-template (table template)
>   "Add or update TEMPLATE in TABLE.
> 
> Also takes care of adding and updating to the associated menu."
>   ;; Remove from table by uuid
>   ;;
>   (yas--remove-template-by-uuid table (yas--template-uuid template))
>   ;; Add to table again
>   ;;
>   (yas--add-template table template)
>   ;; Take care of the menu
>   ;;
>   (when yas-use-menu
>     (yas--update-template-menu table template)))
866,910c1100,1156
<   ;; This is dones by searching twice:
<   ;;
<   ;; * Try to get the existing namehash from TABLE using key.
<   ;;
<   ;; * Try to get the existing namehash from by searching the *whole*
<   ;; snippet table for NAME. This is becuase they user might have
<   ;; changed the key and that can no longer be used to locate the
<   ;; previous `yas/template-structure'.
<   ;;
<   ;; * If that returns nothing, oh well...
<   ;;
<   (dolist (existing-namehash (remove nil (list (gethash key (yas/snippet-table-hash table))
<                                                (when yas/better-guess-for-replacements
<                                                  (let (a)
<                                                    (maphash #'(lambda (key namehash)
<                                                                 (when (gethash name namehash)
<                                                                   (setq a namehash)))
<                                                             (yas/snippet-table-hash table))
<                                                    a)))))
<     (let ((existing-template (gethash name existing-namehash)))
<       (when existing-template
<         ;; Remove the existing keybinding
<         (when (yas/template-keybinding existing-template)
<           (define-key
<             (symbol-value (first (yas/template-keybinding existing-template)))
<             (second (yas/template-keybinding existing-template))
<             nil)
<           (setq yas/active-keybindings
<                 (delete (yas/template-keybinding existing-template)
<                         yas/active-keybindings)))
<         ;; Remove the (name . template) mapping from existing-namehash.
<         (remhash name existing-namehash))))
<   ;; Now store the new template independent of the previous steps.
<   ;;
<   (puthash name
<            template
<            (or (gethash key
<                         (yas/snippet-table-hash table))
<                (puthash key
<                         (make-hash-table :test 'equal)
<                         (yas/snippet-table-hash table)))))
< 
< (defun yas/fetch (table key)
<   "Fetch a snippet binding to KEY from TABLE."
<   (let* ((keyhash (yas/snippet-table-hash table))
---
> (defun yas--update-template-menu (table template)
>   "Update every menu-related for TEMPLATE"
>   (let ((menu-binding-pair (yas--template-menu-binding-pair-get-create template))
>         (key (yas--template-key template))
>         (keybinding (yas--template-keybinding template)))
>     ;; The snippet might have changed name or keys, so update
>     ;; user-visible strings
>     ;;
>     (unless (eq (cdr menu-binding-pair) :none)
>       ;; the menu item name
>       ;;
>       (setf (cadar menu-binding-pair) (yas--template-name template))
>       ;; the :keys information (also visible to the user)
>       (setf (getf (cdr (car menu-binding-pair)) :keys)
>             (or (and keybinding (key-description keybinding))
>                 (and key (concat key yas-trigger-symbol))))))
>   (unless (yas--template-menu-managed-by-yas-define-menu template)
>     (let ((menu-keymap
>            (yas--menu-keymap-get-create (yas--table-mode table)
>                                         (mapcar #'yas--table-mode
>                                                 (yas--table-parents table))))
>           (group (yas--template-group template)))
>       ;; Remove from menu keymap
>       ;;
>       (assert menu-keymap)
>       (yas--delete-from-keymap menu-keymap (yas--template-uuid template))
> 
>       ;; Add necessary subgroups as necessary.
>       ;;
>       (dolist (subgroup group)
>         (let ((subgroup-keymap (lookup-key menu-keymap (vector (make-symbol subgroup)))))
>           (unless (and subgroup-keymap
>                        (keymapp subgroup-keymap))
>             (setq subgroup-keymap (make-sparse-keymap))
>             (define-key menu-keymap (vector (make-symbol subgroup))
>               `(menu-item ,subgroup ,subgroup-keymap)))
>           (setq menu-keymap subgroup-keymap)))
> 
>       ;; Add this entry to the keymap
>       ;;
>       (define-key menu-keymap
>         (vector (make-symbol (yas--template-uuid template)))
>         (car (yas--template-menu-binding-pair template))))))
> 
> (defun yas--namehash-templates-alist (namehash)
>   (let (alist)
>     (maphash #'(lambda (k v)
>                  (push (cons k v) alist))
>              namehash)
>     alist))
> 
> (defun yas--fetch (table key)
>   "Fetch templates in TABLE by KEY.
> 
> Return a list of cons (NAME . TEMPLATE) where NAME is a
> string and TEMPLATE is a `yas--template' structure."
>   (let* ((keyhash (yas--table-hash table))
913,918c1159
<       (yas/filter-templates-by-condition
<        (let (alist)
<          (maphash #'(lambda (k v)
<                       (push (cons k v) alist))
<                   namehash)
<          alist)))))
---
>       (yas--filter-templates-by-condition (yas--namehash-templates-alist namehash)))))
921c1162
< ;; Filtering/condition logic
---
> ;;; Filtering/condition logic
923c1164
< (defun yas/eval-condition (condition)
---
> (defun yas--eval-condition (condition)
930,931c1171
<              (message (format "[yas] error in condition evaluation: %s"
<                               (error-message-string err)))
---
>              (yas--message 1 "Error in condition evaluation: %s" (error-message-string err))
935c1175
< (defun yas/filter-templates-by-condition (templates)
---
> (defun yas--filter-templates-by-condition (templates)
939c1179
< string and TEMPLATE is a `yas/template' structure.
---
> string and TEMPLATE is a `yas--template' structure.
942,943c1182,1183
< `yas/buffer-local-condition'.  See that variables documentation."
<   (let ((requirement (yas/require-template-specific-condition-p)))
---
> `yas-buffer-local-condition'.  See that variables documentation."
>   (let ((requirement (yas--require-template-specific-condition-p)))
947c1187,1188
<                          (yas/template-can-expand-p (yas/template-condition (cdr pair)) requirement))
---
>                          (yas--template-can-expand-p
>                           (yas--template-condition (cdr pair)) requirement))
950c1191
< (defun yas/require-template-specific-condition-p ()
---
> (defun yas--require-template-specific-condition-p ()
953c1194
<   (if (eq 'always yas/buffer-local-condition)
---
>   (if (eq 'always yas-buffer-local-condition)
955,957c1196,1198
<     (let ((local-condition (or (and (consp yas/buffer-local-condition)
<                                     (yas/eval-condition yas/buffer-local-condition))
<                                yas/buffer-local-condition)))
---
>     (let ((local-condition (or (and (consp yas-buffer-local-condition)
>                                     (yas--eval-condition yas-buffer-local-condition))
>                                yas-buffer-local-condition)))
966c1207
< (defun yas/template-can-expand-p (condition &optional requirement)
---
> (defun yas--template-can-expand-p (condition requirement)
968,977c1209,1210
<   (let* ((requirement (or requirement
<                           (yas/require-template-specific-condition-p)))
<          (result (or (null condition)
<                      (yas/eval-condition
<                       (condition-case err
<                           (read condition)
<                         (error (progn
<                                  (message (format "[yas] error reading condition: %s"
<                                                   (error-message-string err))))
<                                nil))))))
---
>   (let* ((result (or (null condition)
>                      (yas--eval-condition condition))))
983,987c1216,1220
< (defun yas/snippet-table-get-all-parents (table)
<   (let ((parents (yas/snippet-table-parents table)))
<     (when parents
<       (append (copy-list parents)
<               (mapcan #'yas/snippet-table-get-all-parents parents)))))
---
> (defun yas--all-parents (mode)
>   "Returns a list of all parent modes of MODE"
>   (let ((parents (gethash mode yas--parents)))
>     (append parents
>             (mapcan #'yas--all-parents parents))))
989c1222
< (defun yas/snippet-table-templates (table)
---
> (defun yas--table-templates (table)
996,997c1229,1230
<                (yas/snippet-table-hash table))
<       (yas/filter-templates-by-condition acc))))
---
>                (yas--table-hash table))
>       (yas--filter-templates-by-condition acc))))
999c1232
< (defun yas/current-key ()
---
> (defun yas--current-key ()
1004c1237
<         (syntaxes yas/key-syntaxes)
---
>         (syntaxes yas-key-syntaxes)
1016,1017c1249,1250
<                         (yas/fetch table (buffer-substring-no-properties start end)))
<                     (yas/get-snippet-tables)))
---
>                         (yas--fetch table (buffer-substring-no-properties start end)))
>                     (yas--get-snippet-tables)))
1026,1033c1259,1269
< (defun yas/snippet-table-all-keys (table)
<   (when table
<     (let ((acc))
<       (maphash #'(lambda (key templates)
<                    (when (yas/filter-templates-by-condition templates)
<                      (push key acc)))
<                (yas/snippet-table-hash table))
<       acc)))
---
> (defun yas--table-all-keys (table)
>   "Get trigger keys of all active snippets in TABLE"
>   (let ((acc))
>     (maphash #'(lambda (key namehash)
>                  (when (yas--filter-templates-by-condition (yas--namehash-templates-alist namehash))
>                    (push key acc)))
>              (yas--table-hash table))
>     acc))
> 
> (defun yas--table-mode (table)
>   (intern (yas--table-name table)))
1036,1037c1272
< ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
< ;; Internal functions
---
> ;;; Internal functions:
1039c1274
< (defun yas/real-mode? (mode)
---
> (defun yas--real-mode? (mode)
1046c1281
<       (find mode yas/known-modes)))
---
>       (find mode yas--known-modes)))
1048,1052c1283,1285
< (defun yas/read-and-eval-string (string)
<   ;; TODO: This is a possible optimization point, the expression could
<   ;; be stored in cons format instead of string,
<   "Evaluate STRING and convert the result to string."
<   (let ((retval (catch 'yas/exception
---
> (defun yas--eval-lisp (form)
>   "Evaluate FORM and convert the result to string."
>   (let ((retval (catch 'yas--exception
1058c1291
<                             (let ((result (eval (read string))))
---
>                             (let ((result (eval form)))
1061,1063c1294,1296
<                     (error (if yas/good-grace
<                                "[yas] elisp error!"
<                              (error (format "[yas] elisp error: %s"
---
>                     (error (if yas-good-grace
>                                (yas--format "elisp error! %s" (error-message-string err))
>                              (error (yas--format "elisp error: %s"
1066c1299
<                (eq 'yas/exception (car retval)))
---
>                (eq 'yas--exception (car retval)))
1070,1079c1303,1347
< (defvar yas/mode-symbol nil
<   "If non-nil, lookup snippets using this instead of `major-mode'.")
< (make-variable-buffer-local 'yas/mode-symbol)
< 
< (defun yas/snippet-table-get-create (mode)
<   "Get the snippet table corresponding to MODE.
< 
< Optional DIRECTORY gets recorded as the default directory to
< search for snippet files if the retrieved/created table didn't
< already have such a property."
---
> (defun yas--eval-lisp-no-saves (form)
>   (condition-case err
>       (eval form)
>     (error (if yas-good-grace
>                (yas--format "elisp error! %s" (error-message-string err))
>              (error (yas--format "elisp error: %s"
>                             (error-message-string err)))))))
> 
> (defun yas--read-lisp (string &optional nil-on-error)
>   "Read STRING as a elisp expression and return it.
> 
> In case STRING in an invalid expression and NIL-ON-ERROR is nil,
> return an expression that when evaluated will issue an error."
>   (condition-case err
>       (read string)
>     (error (and (not nil-on-error)
>                 `(error (error-message-string ,err))))))
> 
> (defun yas--read-keybinding (keybinding)
>   "Read KEYBINDING as a snippet keybinding, return a vector."
>   (when (and keybinding
>              (not (string-match "keybinding" keybinding)))
>     (condition-case err
>         (let ((res (or (and (string-match "^\\[.*\\]$" keybinding)
>                             (read keybinding))
>                        (read-kbd-macro keybinding 'need-vector))))
>           res)
>       (error
>        (yas--message 3 "warning: keybinding \"%s\" invalid since %s."
>                 keybinding (error-message-string err))
>        nil))))
> 
> (defvar yas-extra-modes nil
>   "If non-nil, also lookup snippets for this/these modes.
> 
> Can be a symbol or a list of symbols.
> 
> This variable probably makes more sense as buffer-local, so
> ensure your use `make-local-variable' when you set it.")
> (defun yas-extra-modes ()
>   (if (listp yas-extra-modes) yas-extra-modes (list yas-extra-modes)))
> (defvaralias 'yas/mode-symbol 'yas-extra-modes)
> 
> (defun yas--table-get-create (mode)
>   "Get or create the snippet table corresponding to MODE."
1081c1349
<                         yas/snippet-tables)))
---
>                         yas--tables)))
1083,1084c1351,1355
<       (setq table (yas/make-snippet-table (symbol-name mode)))
<       (puthash mode table yas/snippet-tables))
---
>       (setq table (yas--make-snippet-table (symbol-name mode)))
>       (puthash mode table yas--tables)
>       (push (cons (intern (format "yas--direct-%s" mode))
>                   (yas--table-direct-keymap table))
>             yas--direct-keymaps))
1087c1358
< (defun yas/get-snippet-tables (&optional mode-symbol dont-search-parents)
---
> (defun yas--get-snippet-tables ()
1090,1119c1361,1379
< Return a list of 'yas/snippet-table' objects indexed by mode.
< 
< The modes are tried in this order: optional MODE-SYMBOL, then
< `yas/mode-symbol', then `major-mode' then, unless
< DONT-SEARCH-PARENTS is non-nil, the guessed parent mode of either
< MODE-SYMBOL or `major-mode'.
< 
< Guessing is done by looking up the MODE-SYMBOL's
< `derived-mode-parent' property, see also `derived-mode-p'."
<   (let ((mode-tables
<          (mapcar #'(lambda (mode)
<                      (gethash mode yas/snippet-tables))
<                  (append (list mode-symbol)
<                          (if (listp yas/mode-symbol)
<                              yas/mode-symbol
<                            (list yas/mode-symbol))
<                          (list major-mode
<                                (and (not dont-search-parents)
<                                     (get (or mode-symbol major-mode)
<                                          'derived-mode-parent))))))
<         (all-tables))
<     (dolist (table (remove nil mode-tables))
<       (push table all-tables)
<       (nconc all-tables (yas/snippet-table-get-all-parents table)))
<     (remove-duplicates all-tables)))
< 
< (defun yas/menu-keymap-get-create (mode)
<   "Get the menu keymap correspondong to MODE."
<   (or (gethash mode yas/menu-table)
<       (puthash mode (make-sparse-keymap) yas/menu-table)))
---
> Return a list of `yas--table' objects. The list of modes to
> consider is returned by `yas--modes-to-activate'"
>   (remove nil
>           (mapcar #'(lambda (mode-name)
>                       (gethash mode-name yas--tables))
>                   (yas--modes-to-activate))))
> 
> (defun yas--menu-keymap-get-create (mode &optional parents)
>   "Get or create the menu keymap for MODE and its PARENTS.
> 
> This may very well create a plethora of menu keymaps and arrange
> them all in `yas--menu-table'"
>   (let* ((menu-keymap (or (gethash mode yas--menu-table)
>                           (puthash mode (make-sparse-keymap) yas--menu-table))))
>     (mapc #'yas--menu-keymap-get-create parents)
>     (define-key yas--minor-mode-menu (vector mode)
>         `(menu-item ,(symbol-name mode) ,menu-keymap
>                     :visible (yas--show-menu-p ',mode)))
>     menu-keymap))
1124c1384
< (defun yas/parse-template (&optional file)
---
> (defun yas--parse-template (&optional file)
1129a1390,1392
> Optional GROUP is the group where the template is to go,
> otherwise we attempt to calculate it from FILE.
> 
1132c1395
<  (KEY TEMPLATE NAME CONDITION GROUP VARS FILE KEYBINDING)
---
>  (KEY TEMPLATE NAME CONDITION GROUP VARS FILE KEYBINDING UUID)
1134,1136c1397,1398
< If the buffer contains a line of \"# --\" then the contents
< above this line are ignored. Variables can be set above this
< line through the syntax:
---
> If the buffer contains a line of \"# --\" then the contents above
> this line are ignored. Directives can set most of these with the syntax:
1138c1400
< #name : value
---
> # directive-name : directive-value
1140c1402
< Here's a list of currently recognized variables:
---
> Here's a list of currently recognized directives:
1141a1404
>  * type
1145d1407
<  * key
1146a1409
>  * key
1148,1153c1411,1412
< 
< #name: #include \"...\"
< # --
< #include \"$1\""
<   ;;
<   ;;
---
>  * binding
>  * uuid"
1155c1414,1415
<   (let* ((name (and file
---
>   (let* ((type 'snippet)
>          (name (and file
1157,1159c1417
<          (key (unless yas/ignore-filenames-as-triggers
<                 (and name
<                      (file-name-sans-extension name))))
---
>          (key nil)
1164c1422
<                      (yas/calculate-group file)))
---
>                      (yas--calculate-group file)))
1166c1424,1425
<          binding)
---
>          binding
>          uuid)
1173a1433,1440
>                  (when (string= "uuid" (match-string-no-properties 1))
>                    (setq uuid (match-string-no-properties 2)))
>                  (when (string= "type" (match-string-no-properties 1))
>                    (setq type (if (string= "command" (match-string-no-properties 2))
>                                   'command
>                                 'snippet)))
>                  (when (string= "key" (match-string-no-properties 1))
>                    (setq key (match-string-no-properties 2)))
1177c1444
<                    (setq condition (match-string-no-properties 2)))
---
>                    (setq condition (yas--read-lisp (match-string-no-properties 2))))
1181,1183c1448,1449
<                    (setq expand-env (match-string-no-properties 2)))
<                  (when (string= "key" (match-string-no-properties 1))
<                    (setq key (match-string-no-properties 2)))
---
>                    (setq expand-env (yas--read-lisp (match-string-no-properties 2)
>                                                    'nil-on-error)))
1188c1454,1460
<     (list key template name condition group expand-env file binding)))
---
>     (unless (or key binding)
>       (setq key (and file (file-name-nondirectory file))))
>     (when (eq type 'command)
>       (setq template (yas--read-lisp (concat "(progn" template ")"))))
>     (when group
>       (setq group (split-string group "\\.")))
>     (list key template name condition group expand-env file binding uuid)))
1190c1462
< (defun yas/calculate-group (file)
---
> (defun yas--calculate-group (file)
1207,1236c1479,1480
< ;; (defun yas/glob-files (directory &optional recurse-p append)
< ;;   "Returns files under DIRECTORY ignoring dirs and hidden files.
< 
< ;; If RECURSE in non-nil, do that recursively."
< ;;   (let (ret
< ;;         (default-directory directory))
< ;;     (dolist (entry (directory-files "."))
< ;;       (cond ((or (string-match "^\\."
< ;;                                (file-name-nondirectory entry))
< ;;                  (string-match "~$"
< ;;                                (file-name-nondirectory entry)))
< ;;              nil)
< ;;             ((and recurse-p
< ;;                   (file-directory-p entry))
< ;;              (setq ret (nconc ret
< ;;                               (yas/glob-files (expand-file-name entry)
< ;;                                               recurse-p
< ;;                                               (if append
< ;;                                                   (concat append "/" entry)
< ;;                                                 entry)))))
< ;;             ((file-directory-p entry)
< ;;              nil)
< ;;             (t
< ;;              (push (if append
< ;;                        (concat append "/" entry)
< ;;                      entry) ret))))
< ;;     ret))
< 
< (defun yas/subdirs (directory &optional file?)
<   "Return subdirs or files of DIRECTORY according to FILE?."
---
> (defun yas--subdirs (directory &optional filep)
>   "Return subdirs or files of DIRECTORY according to FILEP."
1239a1484,1485
>                    (string-match "^#.*#$"
>                                  (file-name-nondirectory file))
1242c1488
<                    (if file?
---
>                    (if filep
1247,1258c1493,1510
< (defun yas/make-menu-binding (template)
<   `(lambda () (interactive) (yas/expand-or-visit-from-menu ,template)))
< 
< (defun yas/expand-or-visit-from-menu (template)
<   (if yas/visit-from-menu
<       (yas/visit-snippet-file-1 template)
<     (let ((where (if mark-active
<                      (cons (region-beginning) (region-end))
<                    (cons (point) (point)))))
<       (yas/expand-snippet (yas/template-content template)
<                           (car where)
<                           (cdr where)))))
---
> (defun yas--make-menu-binding (template)
>   (let ((mode (yas--table-mode (yas--template-table template))))
>     `(lambda () (interactive) (yas--expand-or-visit-from-menu ',mode ,(yas--template-uuid template)))))
> 
> (defun yas--expand-or-visit-from-menu (mode uuid)
>   (let* ((table (yas--table-get-create mode))
>          (yas--current-template (and table
>                                     (gethash uuid (yas--table-uuidhash table)))))
>     (when yas--current-template
>       (if yas-visit-from-menu
>           (yas--visit-snippet-file-1 yas--current-template)
>         (let ((where (if (region-active-p)
>                          (cons (region-beginning) (region-end))
>                        (cons (point) (point)))))
>           (yas-expand-snippet (yas--template-content yas--current-template)
>                               (car where)
>                               (cdr where)
>                               (yas--template-expand-env yas--current-template)))))))
1263c1515,1519
< (defun yas/prompt-for-template (templates &optional prompt)
---
> (defvar yas--x-pretty-prompt-templates nil
>   "If non-nil, attempt to prompt for templates like TextMate.")
> 
> 
> (defun yas--prompt-for-template (templates &optional prompt)
1266c1522
< TEMPLATES is a list of `yas/template'."
---
> TEMPLATES is a list of `yas--template'."
1268,1272c1524,1534
<     (some #'(lambda (fn)
<               (funcall fn (or prompt "Choose a snippet: ")
<                        templates
<                        #'yas/template-name))
<           yas/prompt-functions)))
---
>     (setq templates
>           (sort templates #'(lambda (t1 t2)
>                               (< (length (yas--template-name t1))
>                                  (length (yas--template-name t2))))))
>     (if yas--x-pretty-prompt-templates
>         (yas--x-pretty-prompt-templates "Choose a snippet" templates)
>       (some #'(lambda (fn)
>                 (funcall fn (or prompt "Choose a snippet: ")
>                          templates
>                          #'yas--template-name))
>             yas-prompt-functions))))
1274c1536
< (defun yas/prompt-for-keys (keys &optional prompt)
---
> (defun yas--prompt-for-keys (keys &optional prompt)
1279c1541
<           yas/prompt-functions)))
---
>           yas-prompt-functions)))
1281c1543
< (defun yas/prompt-for-table (tables &optional prompt)
---
> (defun yas--prompt-for-table (tables &optional prompt)
1286,1287c1548,1549
<                        #'yas/snippet-table-name))
<           yas/prompt-functions)))
---
>                        #'yas--table-name))
>           yas-prompt-functions)))
1289c1551,1559
< (defun yas/x-prompt (prompt choices &optional display-fn)
---
> (defun yas-x-prompt (prompt choices &optional display-fn)
>   "Display choices in a x-window prompt."
>   ;; FIXME: HACK: if we notice that one of the objects in choices is
>   ;; actually a `yas--template', defer to `yas--x-prompt-pretty-templates'
>   ;;
>   ;; This would be better implemented by passing CHOICES as a
>   ;; strucutred tree rather than a list. Modifications would go as far
>   ;; up as `yas--all-templates' I think.
>   ;;
1291,1303c1561,1571
<     (let ((keymap (cons 'keymap
<                         (cons
<                          prompt
<                          (mapcar (lambda (choice)
<                                    (list choice
<                                          'menu-item
<                                          (if display-fn
<                                              (funcall display-fn choice)
<                                            choice)
<                                          t))
<                                  choices)))))
<       (when (cdr keymap)
<         (car (x-popup-menu (if (fboundp 'posn-at-point)
---
>     (let ((chosen
>            (let (menu d) ;; d for display
>              (dolist (c choices)
>                (setq d (or (and display-fn (funcall display-fn c))
>                            c))
>                (cond ((stringp d)
>                       (push (cons (concat "   " d) c) menu))
>                      ((listp d)
>                       (push (car d) menu))))
>              (setq menu (list prompt (push "title" menu)))
>              (x-popup-menu (if (fboundp 'posn-at-point)
1309,1325c1577,1616
<                            keymap))))))
< 
< (defun yas/ido-prompt (prompt choices &optional display-fn)
<   (when (and (featurep 'ido)
<              ido-mode)
<     (let* ((formatted-choices (or (and display-fn
<                                        (mapcar display-fn choices))
<                                   choices))
<            (chosen (and formatted-choices
<                         (ido-completing-read prompt
<                                              formatted-choices
<                                              nil
<                                              'require-match
<                                              nil
<                                              nil))))
<       (when chosen
<         (nth (position chosen formatted-choices :test #'string=) choices)))))
---
>                            menu))))
>       (or chosen
>           (keyboard-quit)))))
> 
> (defun yas--x-pretty-prompt-templates (prompt templates)
>   "Display TEMPLATES, grouping neatly by table name."
>   (let ((organized (make-hash-table :test #'equal))
>         menu
>         more-than-one-table
>         prefix)
>     (dolist (tl templates)
>       (puthash (yas--template-table tl)
>                (cons tl
>                      (gethash (yas--template-table tl) organized))
>                organized))
>     (setq more-than-one-table (> (hash-table-count organized) 1))
>     (setq prefix (if more-than-one-table
>                      "   " ""))
>     (if more-than-one-table
>         (maphash #'(lambda (table templates)
>                      (push (yas--table-name table) menu)
>                      (dolist (tl templates)
>                        (push (cons (concat prefix (yas--template-name tl)) tl) menu))) organized)
>       (setq menu (mapcar #'(lambda (tl) (cons (concat prefix (yas--template-name tl)) tl)) templates)))
> 
>     (setq menu (nreverse menu))
>     (or (x-popup-menu (if (fboundp 'posn-at-point)
>                           (let ((x-y (posn-x-y (posn-at-point (point)))))
>                             (list (list (+ (car x-y) 10)
>                                         (+ (cdr x-y) 20))
>                                   (selected-window)))
>                         t)
>                       (list prompt (push "title" menu)))
>         (keyboard-quit))))
> 
> (defun yas-ido-prompt (prompt choices &optional display-fn)
>   (when (and (fboundp 'ido-completing-read)
> 	     (or (>= emacs-major-version 24)
> 		 ido-mode))
>     (yas-completing-prompt prompt choices display-fn #'ido-completing-read)))
1328c1619
< (defun yas/dropdown-prompt (prompt choices &optional display-fn)
---
> (defun yas-dropdown-prompt (prompt choices &optional display-fn)
1330,1350c1621,1660
<     (let* ((formatted-choices (or (and display-fn
<                                        (mapcar display-fn choices))
<                                   choices))
<            (chosen (and formatted-choices
<                         (nth (dropdown-list formatted-choices)
<                              choices))))
<       chosen)))
< 
< (defun yas/completing-prompt (prompt choices &optional display-fn)
<   (let* ((formatted-choices (or (and display-fn
<                                      (mapcar display-fn choices))
<                                 choices))
<          (chosen (and formatted-choices
<                       (completing-read prompt
<                                        formatted-choices
<                                        nil
<                                        'require-match
<                                        nil
<                                        nil))))
<     (when chosen
<       (nth (position chosen formatted-choices :test #'string=) choices))))
---
>     (let (formatted-choices
>           filtered-choices
>           d
>           n)
>       (dolist (choice choices)
>         (setq d (or (and display-fn (funcall display-fn choice))
>                       choice))
>         (when (stringp d)
>           (push d formatted-choices)
>           (push choice filtered-choices)))
> 
>       (setq n (and formatted-choices (dropdown-list formatted-choices)))
>       (if n
>           (nth n filtered-choices)
>         (keyboard-quit)))))
> 
> (defun yas-completing-prompt (prompt choices &optional display-fn completion-fn)
>   (let (formatted-choices
>         filtered-choices
>         chosen
>         d
>         (completion-fn (or completion-fn
>                            #'completing-read)))
>     (dolist (choice choices)
>       (setq d (or (and display-fn (funcall display-fn choice))
>                     choice))
>       (when (stringp d)
>         (push d formatted-choices)
>         (push choice filtered-choices)))
>     (setq chosen (and formatted-choices
>                       (funcall completion-fn prompt
>                                formatted-choices
>                                nil
>                                'require-match
>                                nil
>                                nil)))
>     (let ((position (or (and chosen
>                              (position chosen formatted-choices :test #'string=))
>                         0)))
>       (nth position filtered-choices))))
1352c1662
< (defun yas/no-prompt (prompt choices &optional display-fn)
---
> (defun yas-no-prompt (prompt choices &optional display-fn)
1358,1407c1668,1669
< (defun yas/load-directory-1 (directory &optional parents no-hierarchy-parents making-groups-sym)
<   "Recursively load snippet templates from DIRECTORY."
<   ;; TODO: Rewrite this horrible, horrible monster I created
<   (unless (file-exists-p (concat directory "/" ".yas-skip"))
<     (let* ((major-mode-and-parents (unless making-groups-sym
<                                      (yas/compute-major-mode-and-parents (concat directory "/dummy")
<                                                                          nil
<                                                                          no-hierarchy-parents)))
<            (yas/ignore-filenames-as-triggers (or yas/ignore-filenames-as-triggers
<                                                  (file-exists-p (concat directory "/" ".yas-ignore-filenames-as-triggers"))))
<            (mode-sym (and major-mode-and-parents
<                           (car major-mode-and-parents)))
<            (parents (if making-groups-sym
<                         parents
<                       (rest major-mode-and-parents)))
<            (snippet-defs nil)
<            (make-groups-p (or making-groups-sym
<                               (file-exists-p (concat directory "/" ".yas-make-groups")))))
<       (with-temp-buffer
<         (dolist (file (yas/subdirs directory 'no-subdirs-just-files))
<           (when (file-readable-p file)
<             (insert-file-contents file nil nil nil t)
<             (push (yas/parse-template file)
<                   snippet-defs))))
<       (yas/define-snippets (or mode-sym
<                                making-groups-sym)
<                            snippet-defs
<                            parents)
<       (dolist (subdir (yas/subdirs directory))
<         (if make-groups-p
<             (yas/load-directory-1 subdir parents 't (or mode-sym
<                                                         making-groups-sym))
<           (yas/load-directory-1 subdir (list mode-sym)))))))
< 
< (defun yas/load-directory (directory)
<   "Load snippet definition from a directory hierarchy.
< 
< Below the top-level directory, each directory is a mode
< name.  And under each subdirectory, each file is a definition
< of a snippet.  The file name is the trigger key and the
< content of the file is the template."
<   (interactive "DSelect the root directory: ")
<   (unless (file-directory-p directory)
<     (error "Error %s not a directory" directory))
<   (unless yas/root-directory
<     (setq yas/root-directory directory))
<   (dolist (dir (yas/subdirs directory))
<     (yas/load-directory-1 dir nil 'no-hierarchy-parents))
<   (when (interactive-p)
<     (message "done.")))
---
> (defun yas--load-yas-setup-file (file)
>   (load file 'noerror))
1409,1414c1671,1672
< (defun yas/kill-snippet-keybindings ()
<   "Remove the all active snippet keybindings."
<   (interactive)
<   (dolist (keybinding yas/active-keybindings)
<     (define-key (symbol-value (first keybinding)) (second keybinding) nil))
<   (setq yas/active-keybindings nil))
---
> (defun yas-load-directory (top-level-dir &optional use-jit)
>   "Load snippets in directory hierarchy TOP-LEVEL-DIR.
1416,1434c1674
< (defun yas/reload-all (&optional reset-root-directory)
<   "Reload all snippets and rebuild the YASnippet menu. "
<   (interactive "P")
<   ;; Turn off global modes and minor modes, save their state though
<   ;;
<   (let ((restore-global-mode (prog1 yas/global-mode
<                                (yas/global-mode -1)))
<         (restore-minor-mode (prog1 yas/minor-mode
<                               (yas/minor-mode -1))))
<     ;; Empty all snippet tables and all menu tables
<     ;;
<     (setq yas/snippet-tables (make-hash-table))
<     (setq yas/menu-table (make-hash-table))
< 
<     ;; Init the `yas/minor-mode-map', taking care not to break the
<     ;; menu....
<     ;;
<     (setf (cdr yas/minor-mode-map)
<           (cdr (yas/init-minor-keymap)))
---
> Below TOP-LEVEL-DIR each directory should be a mode name.
1436,1437c1676,1705
<     ;; Now, clean up the other keymaps we might have cluttered up.
<     (yas/kill-snippet-keybindings)
---
> Optional USE-JIT use jit-loading of snippets."
>   (interactive "DSelect the root directory: ")
>   (unless yas-snippet-dirs
>     (setq yas-snippet-dirs top-level-dir))
>   (dolist (dir (yas--subdirs top-level-dir))
>     (let* ((major-mode-and-parents (yas--compute-major-mode-and-parents
>                                     (concat dir "/dummy")))
>            (mode-sym (car major-mode-and-parents))
>            (parents (cdr major-mode-and-parents)))
>       ;; Attention: The parents and the menus are already defined
>       ;; here, even if the snippets are later jit-loaded.
>       ;;
>       ;; * We need to know the parents at this point since entering a
>       ;;   given mode should jit load for its parents
>       ;;   immediately. This could be reviewed, the parents could be
>       ;;   discovered just-in-time-as well
>       ;;
>       ;; * We need to create the menus here to support the `full'
>       ;;   option to `yas-use-menu' (all known snippet menus are shown to the user)
>       ;;
>       (yas--define-parents mode-sym parents)
>       (yas--menu-keymap-get-create mode-sym)
>       (let ((form `(yas--load-directory-1 ,dir
>                                          ',mode-sym
>                                          ',parents)))
>         (if use-jit
>             (yas--schedule-jit mode-sym form)
>             (eval form)))))
>   (when (interactive-p)
>     (yas--message 3 "Loaded snippets from %s." top-level-dir)))
1439,1440c1707,1714
<     (when reset-root-directory
<       (setq yas/root-directory nil))
---
> (defun yas--load-directory-1 (directory mode-sym parents &optional no-compiled-snippets)
>   "Recursively load snippet templates from DIRECTORY."
>   (unless (file-exists-p (concat directory "/" ".yas-skip"))
>     (if (and (not no-compiled-snippets)
>              (progn (yas--message 2 "Loading compiled snippets from %s" directory) t)
>              (load (expand-file-name ".yas-compiled-snippets" directory) 'noerror (<= yas-verbosity 3)))
>       (yas--message 2 "Loading snippet files from %s" directory)
>       (yas--load-directory-2 directory mode-sym))))
1442,1443c1716,1722
<     ;; Reload the directories listed in `yas/root-directory' or prompt
<     ;; the user to select one.
---
> (defun yas--load-directory-2 (directory mode-sym)
>   ;; Load .yas-setup.el files wherever we find them
>   ;;
>   (yas--load-yas-setup-file (expand-file-name ".yas-setup" directory))
>   (let* ((default-directory directory)
>          (snippet-defs nil))
>     ;; load the snippet files
1445,1452c1724,1733
<     (if yas/root-directory
<         (if (listp yas/root-directory)
<             (dolist (directory yas/root-directory)
<               (yas/load-directory directory))
<           (yas/load-directory yas/root-directory))
<       (call-interactively 'yas/load-directory))
< 
<     ;; Restore the mode configuration
---
>     (with-temp-buffer
>       (dolist (file (yas--subdirs directory 'no-subdirs-just-files))
>         (when (file-readable-p file)
>           (insert-file-contents file nil nil nil t)
>           (push (yas--parse-template file)
>                 snippet-defs))))
>     (when snippet-defs
>       (yas-define-snippets mode-sym
>                            snippet-defs))
>     ;; now recurse to a lower level
1454,1457c1735,1819
<     (when restore-minor-mode
<       (yas/minor-mode 1))
<     (when restore-global-mode
<       (yas/global-mode 1))
---
>     (dolist (subdir (yas--subdirs directory))
>       (yas--load-directory-2 subdir
>                             mode-sym))))
> 
> (defun yas--load-snippet-dirs (&optional nojit)
>   "Reload the directories listed in `yas-snippet-dirs' or
>    prompt the user to select one."
>   (let (errors)
>     (if yas-snippet-dirs
>         (dolist (directory (reverse (yas-snippet-dirs)))
>           (cond ((file-directory-p directory)
>                  (yas-load-directory directory (not nojit))
>                  (if nojit
>                      (yas--message 3 "Loaded %s" directory)
>                    (yas--message 3 "Prepared just-in-time loading for %s" directory)))
>                 (t
>                  (push (yas--message 0 "Check your `yas-snippet-dirs': %s is not a directory" directory) errors))))
>       (call-interactively 'yas-load-directory))
>     errors))
> 
> (defun yas-reload-all (&optional interactive)
>   "Reload all snippets and rebuild the YASnippet menu.
> 
> When called interactively force immediate reload of all known
> snippets under `yas-snippet-dirs', otherwise use just-in-time
> loading."
>   (interactive "p")
>   (catch 'abort
>     (let ((errors)
>           (snippet-editing-buffers
>            (remove-if-not #'(lambda (buffer)
>                               (with-current-buffer buffer yas--editing-template))
>                           (buffer-list))))
>       ;; Warn if there are buffers visiting snippets, since reloading will break
>       ;; any on-line editing of those buffers.
>       ;;
>       (when snippet-editing-buffers
>           (if interactive
>               (if (y-or-n-p "Some buffers editing live snippets, close them and proceed with reload?")
>                   (mapc #'kill-buffer snippet-editing-buffers)
>                 (yas--message 1 "Aborted reload...")
>                 (throw 'abort nil))
>             ;; in a non-interactive use, at least set
>             ;; `yas--editing-template' to nil, make it guess it next time around
>             (mapc #'(lambda (buffer) (setq yas--editing-template nil)) (buffer-list))))
> 
>       ;; Empty all snippet tables, parenting info and all menu tables
>       ;;
>       (setq yas--tables (make-hash-table))
>       (setq yas--parents (make-hash-table))
>       (setq yas--menu-table (make-hash-table))
> 
>       ;; Cancel all pending 'yas--scheduled-jit-loads'
>       ;;
>       (setq yas--scheduled-jit-loads (make-hash-table))
> 
>       ;; Init the `yas-minor-mode-map', taking care not to break the
>       ;; menu....
>       ;;
>       (setcdr yas-minor-mode-map (cdr (yas--init-minor-keymap)))
> 
>       ;; Reload the directories listed in `yas-snippet-dirs' or prompt
>       ;; the user to select one.
>       ;;
>       (setq errors (yas--load-snippet-dirs interactive))
>       ;; Reload the direct keybindings
>       ;;
>       (yas-direct-keymaps-reload)
>       ;; Reload the trigger-key (shoudn't be needed, but see issue #237)
>       ;;
>       (yas--trigger-key-reload)
> 
>       (yas--message 3 "Reloaded everything%s...%s."
>                    (if interactive "" " (snippets will load just-in-time)")
>                    (if errors " (some errors, check *Messages*)" "")))))
> 
> (defun yas--load-pending-jits ()
>   (when yas-minor-mode
>     (dolist (mode (yas--modes-to-activate))
>       (let ((forms (reverse (gethash mode yas--scheduled-jit-loads))))
>         ;; must reverse to maintain coherence with `yas-snippet-dirs'
>         (dolist (form forms)
>           (yas--message  3 "Loading for `%s', just-in-time: %s!" mode form)
>           (eval form))
>         (remhash mode yas--scheduled-jit-loads)))))
1459c1821,1822
<     (message "[yas] Reloading everything... Done.")))
---
> ;; (when (<= emacs-major-version 22)
> ;;   (add-hook 'after-change-major-mode-hook 'yas--load-pending-jits))
1461c1824
< (defun yas/quote-string (string)
---
> (defun yas--quote-string (string)
1471,1479c1834
< ;;; Yasnippet Bundle
< 
< (defun yas/initialize ()
<   "For backward compatibility, enable `yas/minor-mode' globally"
<   (yas/global-mode 1))
< 
< (defun yas/compile-bundle
<   (&optional yasnippet yasnippet-bundle snippet-roots code dropdown)
<   "Compile snippets in SNIPPET-ROOTS to a single bundle file.
---
> ;;; Snippet compilation function
1481c1836,1888
< YASNIPPET is the yasnippet.el file path.
---
> (defun yas--initialize ()
>   "For backward compatibility, enable `yas-minor-mode' globally"
>   (yas-global-mode 1))
> 
> (defun yas-compile-directory (top-level-dir)
>   "Create .yas-compiled-snippets.el files under subdirs of TOP-LEVEL-DIR.
> 
> This works by stubbing a few functions, then calling
> `yas-load-directory'."
>   (interactive "DTop level snippet directory?")
>   (flet ((yas--load-yas-setup-file
>           (file)
>           (let ((elfile (concat file ".el")))
>             (when (file-exists-p elfile)
>               (insert ";;; .yas-setup.el support file if any:\n;;;\n")
>               (insert-file-contents elfile)
>               (end-of-buffer)
>               )))
>          (yas-define-snippets
>           (mode snippets)
>           (insert ";;; Snippet definitions:\n;;;\n")
>           (let ((literal-snippets (list))
>                 (print-length nil))
>             (dolist (snippet snippets)
>               (let ((key                    (first   snippet))
>                     (template-content       (second  snippet))
>                     (name                   (third   snippet))
>                     (condition              (fourth  snippet))
>                     (group                  (fifth   snippet))
>                     (expand-env             (sixth   snippet))
>                     (file                   nil) ;; (seventh snippet)) ;; omit on purpose
>                     (binding                (eighth  snippet))
>                     (uuid                    (ninth   snippet)))
>                 (push `(,key
>                         ,template-content
>                         ,name
>                         ,condition
>                         ,group
>                         ,expand-env
>                         ,file
>                         ,binding
>                         ,uuid)
>                       literal-snippets)))
>             (insert (pp-to-string `(yas-define-snippets ',mode ',literal-snippets)))
>             (insert "\n\n")))
>          (yas--load-directory-1
>           (dir mode parents &rest ignore)
>           (let ((output-file (concat (file-name-as-directory dir) ".yas-compiled-snippets.el")))
>             (with-temp-file output-file
>               (insert (format ";;; Compiled snippets and support files for `%s'\n" mode))
>               (yas--load-directory-2 dir mode)
>               (insert (format ";;; Do not edit! File generated at %s\n" (current-time-string)))))))
>     (yas-load-directory top-level-dir nil)))
1483c1890,1893
< YASNIPPET-BUNDLE is the output file of the compile result.
---
> (defun yas-recompile-all ()
>   "Compile every dir in `yas-snippet-dirs'."
>   (interactive)
>   (mapc #'yas-compile-directory (yas-snippet-dirs)))
1485,1486d1894
< SNIPPET-ROOTS is a list of root directories that contains the
< snippets definition.
1488,1489c1896,1897
< CODE is the code to be placed at the end of the generated file
< and that can initialize the YASnippet bundle.
---
> ;;; JIT loading
> ;;;
1491,1492c1899,1900
< Last optional argument DROPDOWN is the filename of the
< dropdown-list.el library.
---
> (defvar yas--scheduled-jit-loads (make-hash-table)
>   "Alist of mode-symbols to forms to be evaled when `yas-minor-mode' kicks in.")
1494c1902,1906
< Here's the default value for all the parameters:
---
> (defun yas--schedule-jit (mode form)
>   (puthash mode
>            (cons form
>                  (gethash mode yas--scheduled-jit-loads))
>            yas--scheduled-jit-loads))
1496,1592d1907
<   (yas/compile-bundle \"yasnippet.el\"
<                       \"yasnippet-bundle.el\"
<                       \"snippets\")
<                       \"(yas/initialize-bundle)
<                         ### autoload
<                         (require 'yasnippet-bundle)`\"
<                       \"dropdown-list.el\")
< "
<   (interactive "ffind the yasnippet.el file: \nFTarget bundle file: \nDSnippet directory to bundle: \nMExtra code? \nfdropdown-library: ")
<   
<   (let* ((yasnippet (or yasnippet
<                         "yasnippet.el"))
<          (yasnippet-bundle (or yasnippet-bundle
<                                "./yasnippet-bundle.el"))
<          (snippet-roots (or snippet-roots
<                             "snippets"))
<          (dropdown (or dropdown
<                        "dropdown-list.el"))
<          (code (or (and code
<                         (condition-case err (read code) (error nil))
<                         code)
<                    (concat "(yas/initialize-bundle)"
<                            "\n;;;###autoload" ; break through so that won't
<                            "(require 'yasnippet-bundle)")))
<          (dirs (or (and (listp snippet-roots) snippet-roots)
<                    (list snippet-roots)))
<          (bundle-buffer nil))
<     (with-temp-file yasnippet-bundle
<       (insert ";;; yasnippet-bundle.el --- "
<               "Yet another snippet extension (Auto compiled bundle)\n")
<       (insert-file-contents yasnippet)
<       (goto-char (point-max))
<       (insert "\n")
<       (when dropdown
<         (insert-file-contents dropdown))
<       (goto-char (point-max))
<       (insert ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n")
<       (insert ";;;;      Auto-generated code         ;;;;\n")
<       (insert ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n")
<       (insert "(defun yas/initialize-bundle ()\n"
<               "  \"Initialize YASnippet and load snippets in the bundle.\"")
<       (flet ((yas/define-snippets
<               (mode snippets &optional parent-or-parents)
<               (insert ";;; snippets for " (symbol-name mode) "\n")
<               (let ((literal-snippets (list)))
<                 (dolist (snippet snippets)
<                   (let ((key                    (first   snippet))
<                         (template-content       (second  snippet))
<                         (name                   (third   snippet))
<                         (condition              (fourth  snippet))
<                         (group                  (fifth   snippet))
<                         (expand-env             (sixth   snippet))
<                         ;; Omit the file on purpose
<                         (file                   nil) ;; (seventh snippet)) 
<                         (binding                (eighth  snippet)))
<                     (push `(,key
<                             ,template-content
<                             ,name
<                             ,condition
<                             ,group
<                             ,expand-env
<                             ,file
<                             ,binding)
<                           literal-snippets)))
<                 (insert (pp-to-string `(yas/define-snippets ',mode ',literal-snippets ',parent-or-parents)))
<                 (insert "\n\n"))))
<         (dolist (dir dirs)
<           (dolist (subdir (yas/subdirs dir))
<             (yas/load-directory-1 subdir nil 'no-hierarchy-parents))))
< 
<       (insert (pp-to-string `(yas/global-mode 1)))
<       (insert ")\n\n" code "\n")
< 
<       ;; bundle-specific provide and value for yas/dont-activate
<       (let ((bundle-feature-name (file-name-nondirectory
<                                   (file-name-sans-extension
<                                    yasnippet-bundle)))) 
<         (insert (pp-to-string `(set-default 'yas/dont-activate
<                                             #'(lambda ()
<                                                 (and (or yas/root-directory
<                                                          (featurep ',(make-symbol bundle-feature-name)))
<                                                      (null (yas/get-snippet-tables)))))))
<         (insert (pp-to-string `(provide ',(make-symbol bundle-feature-name)))))
<       
<       (insert ";;; "
<               (file-name-nondirectory yasnippet-bundle)
<               " ends here\n"))))
< 
< (defun yas/compile-textmate-bundle ()
<   (interactive)
<   (yas/compile-bundle "yasnippet.el"
<                       "./yasnippet-textmate-bundle.el"
<                       "extras/imported/"
<                       (concat "(yas/initialize-bundle)"
<                               "\n;;;###autoload" ; break through so that won't
<                               "(require 'yasnippet-textmate-bundle)")
<                       "dropdown-list.el"))
1598c1913
< (defun yas/about ()
---
> (defun yas-about ()
1601c1916
<                    yas/version
---
>                    yas--version
1604c1919,1926
< (defun yas/define-snippets (mode snippets &optional parent-mode)
---
> (defun yas--define-parents (mode parents)
>   "Add PARENTS to the list of MODE's parents"
>   (puthash mode (remove-duplicates
>                  (append parents
>                          (gethash mode yas--parents)))
>            yas--parents))
> 
> (defun yas-define-snippets (mode snippets)
1608c1930,1934
< following form:
---
> following form
> 
>  (KEY TEMPLATE NAME CONDITION GROUP EXPAND-ENV FILE KEYBINDING UUID)
> 
> Within these, only KEY and TEMPLATE are actually mandatory.
1610c1936,1937
<  (KEY TEMPLATE NAME CONDITION GROUP EXPAND-ENV FILE KEYBINDING)
---
> TEMPLATE might be a lisp form or a string, depending on whether
> this is a snippet or a snippet-command.
1612c1939,1941
< Within these, only TEMPLATE is actually mandatory.
---
> CONDITION, EXPAND-ENV and KEYBINDING are lisp forms, they have
> been `yas--read-lisp'-ed and will eventually be
> `yas--eval-lisp'-ed.
1614,1615c1943
< All the elelements are strings, including CONDITION, EXPAND-ENV
< and KEYBINDING which will be `read' and eventually `eval'-ed.
---
> The remaining elements are strings.
1620,1621c1948,1949
< You can use `yas/parse-template' to return such lists based on
< the current buffers contents.
---
> UUID is the snippets \"unique-id\". Loading a second snippet file
> with the same uuid replaced the previous snippet.
1623,1657c1951,1954
< Optional PARENT-MODE can be used to specify the parent tables of
< MODE. It can be a mode symbol of a list of mode symbols. It does
< not need to be a real mode."
<   (let ((snippet-table (yas/snippet-table-get-create mode))
<         (parent-tables (mapcar #'yas/snippet-table-get-create
<                                (if (listp parent-mode)
<                                    parent-mode
<                                  (list parent-mode))))
<         (keymap (if yas/use-menu
<                     (yas/menu-keymap-get-create mode)
<                   nil)))
<     ;; Setup the menu
<     ;;
<     (when parent-tables
<       (setf (yas/snippet-table-parents snippet-table)
<             parent-tables)
<       (when yas/use-menu
<         (let ((parent-menu-syms-and-names
<                (if (listp parent-mode)
<                    (mapcar #'(lambda (sym)
<                                (cons sym (concat "parent mode - " (symbol-name sym))))
<                            parent-mode)
<                  '((parent-mode . "parent mode")))))
<           (mapc #'(lambda (sym-and-name)
<                     (define-key keymap
<                       (vector (intern (replace-regexp-in-string " " "_" (cdr sym-and-name))))
<                       (list 'menu-item (cdr sym-and-name)
<                             (yas/menu-keymap-get-create (car sym-and-name)))))
<                 (reverse parent-menu-syms-and-names)))))
<     (when yas/use-menu
<       (define-key yas/minor-mode-menu (vector mode)
<         `(menu-item ,(symbol-name mode) ,keymap
<                     :visible (yas/show-menu-p ',mode))))
<     ;; Iterate the recently parsed snippets definition
<     ;;
---
> You can use `yas--parse-template' to return such lists based on
> the current buffers contents."
>   (let ((snippet-table (yas--table-get-create mode))
>         (template nil))
1659,1730c1956,1998
<       (let* ((file (seventh snippet))
<              (key (or (car snippet)
<                       (unless yas/ignore-filenames-as-triggers
<                         (and file 
<                              (file-name-sans-extension (file-name-nondirectory file))))))
<              (name (or (third snippet)
<                        (and file
<                             (file-name-directory file))))
<              (condition (fourth snippet))
<              (group (fifth snippet))
<              (keybinding (eighth snippet))
<              (template nil))
<         ;; Read the snippet's "binding :" expression
<         ;;
<         (condition-case err
<             (when keybinding
<               (setq keybinding (read (eighth snippet)))
<               (let* ((this-mode-map-symbol (intern (concat (symbol-name mode) "-map")))
<                      (keys (or (and (consp keybinding)
<                                     (read-kbd-macro (cdr keybinding)))
<                                (read-kbd-macro keybinding)))
<                      (keymap-symbol (or (and (consp keybinding)
<                                              (car keybinding))
<                                         this-mode-map-symbol)))
<                 (if (and (boundp keymap-symbol)
<                          (keymapp (symbol-value keymap-symbol)))
<                     (setq keybinding (list keymap-symbol
<                                            keys
<                                            name))
<                   (error (format "keymap \"%s\" does not (yet?) exist" keymap-symbol)))))
<           (error
<            (message "[yas] warning: keybinding \"%s\" invalid for snippet \"%s\" since %s."
<                     keybinding name (error-message-string err))
<            (setf keybinding nil)))
< 
<         ;; Create the `yas/template' object and store in the
<         ;; appropriate snippet table. This only done if we have found
<         ;; a key and a name for the snippet, because that is what
<         ;; indexes the snippet tables
<         ;;
<         (setq template (yas/make-template (second snippet)
<                                           (or name key)
<                                           condition
<                                           (sixth snippet)
<                                           (seventh snippet)
<                                           keybinding))
<         (when (and key
<                    name)
<           (yas/store snippet-table
<                      name
<                      key
<                      template))
<         ;; If we have a keybinding, register it if it does not
<         ;; conflict!
<         ;;
<         (when keybinding
< 	  (let ((lookup (lookup-key (symbol-value (first keybinding)) (second keybinding))))
< 	    (if (and lookup
< 		     (not (numberp lookup)))
< 		(message "[yas] warning: won't overwrite keybinding \"%s\" for snippet \"%s\" in `%s'"
< 			 (key-description (second keybinding)) name (first keybinding))
< 	      (define-key
< 		(symbol-value (first keybinding))
< 		(second keybinding)
< 		`(lambda (&optional yas/prefix)
< 		   (interactive "P")
< 		   (when (yas/template-can-expand-p ,(yas/template-condition template))
< 		     (yas/expand-snippet ,(yas/template-content template)
< 					 nil
< 					 nil
< 					 ,(yas/template-expand-env template)))))
< 	      (add-to-list 'yas/active-keybindings keybinding))))
---
>       (setq template (yas-define-snippets-1 snippet
>                                             snippet-table)))
>     template))
> 
> (defun yas-define-snippets-1 (snippet snippet-table)
>   "Helper for `yas-define-snippets'."
>   ;; X) Calculate some more defaults on the values returned by
>   ;; `yas--parse-template'.
>   ;;
>   (let* ((file (seventh snippet))
>          (key (car snippet))
>          (name (or (third snippet)
>                    (and file
>                         (file-name-directory file))))
>          (condition (fourth snippet))
>          (group (fifth snippet))
>          (keybinding (yas--read-keybinding (eighth snippet)))
>          (uuid (or (ninth snippet)
>                   name))
>          (template (or (gethash uuid (yas--table-uuidhash snippet-table))
>                        (yas--make-blank-template))))
>     ;; X) populate the template object
>     ;;
>     (yas--populate-template template
>                            :table       snippet-table
>                            :key         key
>                            :content     (second snippet)
>                            :name        (or name key)
>                            :group       group
>                            :condition   condition
>                            :expand-env  (sixth snippet)
>                            :file        (seventh snippet)
>                            :keybinding  keybinding
>                            :uuid         uuid)
>     ;; X) Update this template in the appropriate table. This step
>     ;;    also will take care of adding the key indicators in the
>     ;;    templates menu entry, if any
>     ;;
>     (yas--update-template snippet-table template)
>     ;; X) Return the template
>     ;;
>     ;;
>     template))
1732,1761c2000,2033
<         ;; Setup the menu groups, reorganizing from group to group if
<         ;; necessary
<         ;;
<         (when yas/use-menu
<           (let ((group-keymap keymap))
<             ;; Delete this entry from another group if already exists
<             ;; in some other group. An entry is considered as existing
<             ;; in another group if its name string-matches.
<             ;;
<             (yas/delete-from-keymap group-keymap name)
< 
<             ;; ... then add this entry to the correct group
<             (when (and (not (null group))
<                        (not (string= "" group)))
<               (dolist (subgroup (mapcar #'make-symbol
<                                         (split-string group "\\.")))
<                 (let ((subgroup-keymap (lookup-key group-keymap
<                                                    (vector subgroup))))
<                   (when (null subgroup-keymap)
<                     (setq subgroup-keymap (make-sparse-keymap))
<                     (define-key group-keymap (vector subgroup)
<                       `(menu-item ,(symbol-name subgroup)
<                                   ,subgroup-keymap)))
<                   (setq group-keymap subgroup-keymap))))
<             (define-key group-keymap (vector (gensym))
<               `(menu-item ,(yas/template-name template)
<                           ,(yas/make-menu-binding template)
<                           :help ,name
<                           :keys ,(when (and key name)
<                                    (concat key yas/trigger-symbol))))))))))
---
> 
> ;;; Apropos snippet menu:
> ;;
> ;; The snippet menu keymaps are store by mode in hash table called
> ;; `yas--menu-table'. They are linked to the main menu in
> ;; `yas--menu-keymap-get-create' and are initially created empty,
> ;; reflecting the table hierarchy.
> ;;
> ;; They can be populated in two mutually exclusive ways: (1) by
> ;; reading `yas--template-group', which in turn is populated by the "#
> ;; group:" directives of the snippets or the ".yas-make-groups" file
> ;; or (2) by using a separate `yas-define-menu' call, which declares a
> ;; menu structure based on snippets uuids.
> ;;
> ;; Both situations are handled in `yas--update-template-menu', which
> ;; uses the predicate `yas--template-menu-managed-by-yas-define-menu'
> ;; that can tell between the two situations.
> ;;
> ;; Note:
> ;;
> ;; * if `yas-define-menu' is used it must run before
> ;;   `yas-define-snippets' and the UUIDS must match, otherwise we get
> ;;   duplicate entries. The `yas--template' objects are created in
> ;;   `yas-define-menu', holding nothing but the menu entry,
> ;;   represented by a pair of ((menu-item NAME :keys KEYS) TYPE) and
> ;;   stored in `yas--template-menu-binding-pair'. The (menu-item ...)
> ;;   part is then stored in the menu keymap itself which make the item
> ;;   appear to the user. These limitations could probably be revised.
> ;;
> ;; * The `yas--template-perm-group' slot is only used in
> ;;   `yas-describe-tables'.
> ;;
> (defun yas--template-menu-binding-pair-get-create (template &optional type)
>   "Get TEMPLATE's menu binding or assign it a new one.
1763,1764c2035,2052
< (defun yas/show-menu-p (mode)
<   (cond ((eq yas/use-menu 'abbreviate)
---
> TYPE may be `:stay', signalling this menu binding should be
> static in the menu."
>   (or (yas--template-menu-binding-pair template)
>       (let ((key (yas--template-key template))
>             (keybinding (yas--template-keybinding template)))
>         (setf (yas--template-menu-binding-pair template)
>               (cons `(menu-item ,(or (yas--template-name template)
>                                      (yas--template-uuid template))
>                                 ,(yas--make-menu-binding template)
>                                 :keys ,nil)
>                     type)))))
> (defun yas--template-menu-managed-by-yas-define-menu (template)
>   "Non-nil if TEMPLATE's menu entry was included in a `yas-define-menu' call."
>   (cdr (yas--template-menu-binding-pair template)))
> 
> 
> (defun yas--show-menu-p (mode)
>   (cond ((eq yas-use-menu 'abbreviate)
1767,1772c2055,2060
<                            (intern (yas/snippet-table-name table)))
<                        (yas/get-snippet-tables))))
<         ((eq yas/use-menu 'real-modes)
<          (yas/real-mode? mode))
<         (t
<          t))) 
---
>                            (yas--table-mode table))
>                        (yas--get-snippet-tables))))
>         ((eq yas-use-menu 'full)
>          t)
>         ((eq yas-use-menu t)
>          t)))
1774,1775c2062,2063
< (defun yas/delete-from-keymap (keymap name)
<   "Recursively delete items name NAME from KEYMAP and its submenus.
---
> (defun yas--delete-from-keymap (keymap uuid)
>   "Recursively delete items with UUID from KEYMAP and its submenus."
1777c2065,2066
< Skip any submenus named \"parent mode\""
---
>   ;; XXX: This used to skip any submenus named \"parent mode\"
>   ;;
1783,1786c2072,2074
<             (when (and (keymapp (fourth item))
<                        (stringp (third item))
<                        (not (string-match "parent mode" (third item))))
<               (yas/delete-from-keymap (fourth item) name)))
---
>             (when (and (listp (cdr item))
>                        (keymapp (third (cdr item))))
>               (yas--delete-from-keymap (third (cdr item)) uuid)))
1787a2076,2079
>   ;; Set the uuid entry to nil
>   ;;
>   (define-key keymap (vector (make-symbol uuid)) nil)
>   ;; Destructively modify keymap
1789,1807c2081,2085
<   (when (keymapp keymap)
<     (let ((pos-in-keymap))
<       (while (setq pos-in-keymap
<                    (position-if #'(lambda (item)
<                                     (and (listp item)
<                                          (or
<                                           ;; the menu item we want to delete
<                                           (and (eq 'menu-item (second item))
<                                                (third item)
<                                                (and (string= (third item) name)))
<                                           ;; a stale subgroup
<                                           (and (keymapp (fourth item))
<                                                (not (and (stringp (third item))
<                                                          (string-match "parent mode"
<                                                                        (third item))))
<                                                (null (rest (fourth item)))))))
<                                 keymap))
<         (setf (nthcdr pos-in-keymap keymap)
<               (nthcdr (+ 1 pos-in-keymap) keymap))))))
---
>   (setcdr keymap (delete-if #'(lambda (item)
>                                 (or (null (cdr item))
>                                     (and (keymapp (third (cdr item)))
>                                          (null (cdr (third (cdr item)))))))
>                             (rest keymap))))
1809c2087,2150
< (defun yas/define (mode key template &optional name condition group)
---
> (defun yas-define-menu (mode menu &optional omit-items)
>   "Define a snippet menu for MODE according to MENU, ommitting OMIT-ITEMS.
> 
> MENU is a list, its elements can be:
> 
> - (yas-item UUID) : Creates an entry the snippet identified with
>   UUID. The menu entry for a snippet thus identified is
>   permanent, i.e. it will never move (be reordered) in the menu.
> 
> - (yas-separator) : Creates a separator
> 
> - (yas-submenu NAME SUBMENU) : Creates a submenu with NAME,
>   SUBMENU has the same form as MENU. NAME is also added to the
>   list of groups of the snippets defined thereafter.
> 
> OMIT-ITEMS is a list of snippet uuid's that will always be
> ommited from MODE's menu, even if they're manually loaded.
> 
> This function does nothing if `yas-use-menu' is nil.
> "
>   (when yas-use-menu
>     (let* ((table (yas--table-get-create mode))
>            (hash (yas--table-uuidhash table)))
>       (yas--define-menu-1 table
>                           (yas--menu-keymap-get-create mode)
>                           menu
>                           hash)
>       (dolist (uuid omit-items)
>         (let ((template (or (gethash uuid hash)
>                             (yas--populate-template (puthash uuid
>                                                              (yas--make-blank-template)
>                                                              hash)
>                                                     :table table
>                                                     :uuid uuid))))
>           (setf (yas--template-menu-binding-pair template) (cons nil :none)))))))
> 
> (defun yas--define-menu-1 (table menu-keymap menu uuidhash &optional group-list)
>   (dolist (e (reverse menu))
>     (cond ((eq (first e) 'yas-item)
>            (let ((template (or (gethash (second e) uuidhash)
>                                (yas--populate-template (puthash (second e)
>                                                                (yas--make-blank-template)
>                                                                uuidhash)
>                                                       :table table
>                                                       :perm-group group-list
>                                                       :uuid (second e)))))
>              (define-key menu-keymap (vector (gensym))
>                (car (yas--template-menu-binding-pair-get-create template :stay)))))
>           ((eq (first e) 'yas-submenu)
>            (let ((subkeymap (make-sparse-keymap)))
>              (define-key menu-keymap (vector (gensym))
>                `(menu-item ,(second e) ,subkeymap))
>              (yas--define-menu-1 table
>                                 subkeymap
>                                 (third e)
>                                 uuidhash
>                                 (append group-list (list (second e))))))
>           ((eq (first e) 'yas-separator)
>            (define-key menu-keymap (vector (gensym))
>              '(menu-item "----")))
>           (t
>            (yas--message 3 "Don't know anything about menu entry %s" (first e))))))
> 
> (defun yas--define (mode key template &optional name condition group)
1813c2154
< `yas/use-menu' is `t'.  CONDITION is the condition attached to
---
> `yas-use-menu' is t.  CONDITION is the condition attached to
1816c2157
<   (yas/define-snippets mode
---
>   (yas-define-snippets mode
1819c2160
< (defun yas/hippie-try-expand (first-time?)
---
> (defun yas-hippie-try-expand (first-time?)
1822,1826c2163,2198
<   (if (not first-time?)
<       (let ((yas/fallback-behavior 'return-nil))
<         (yas/expand))
<     (undo 1)
<     nil))
---
>   (when yas-minor-mode
>     (if (not first-time?)
>         (let ((yas-fallback-behavior 'return-nil))
>           (yas-expand))
>       (undo 1)
>       nil)))
> 
> 
> ;;; Apropos condition-cache:
> ;;;
> ;;;
> ;;;
> ;;;
> (defvar yas--condition-cache-timestamp nil)
> (defmacro yas-define-condition-cache (func doc &rest body)
>   "Define a function FUNC with doc DOC and body BODY, BODY is
> executed at most once every snippet expansion attempt, to check
> expansion conditions.
> 
> It doesn't make any sense to call FUNC programatically."
>   `(defun ,func () ,(if (and doc
>                              (stringp doc))
>                         (concat doc
> "\n\nFor use in snippets' conditions. Within each
> snippet-expansion routine like `yas-expand', computes actual
> value for the first time then always returns a cached value.")
>                       (setq body (cons doc body))
>                       nil)
>      (let ((timestamp-and-value (get ',func 'yas--condition-cache)))
>        (if (equal (car timestamp-and-value) yas--condition-cache-timestamp)
>            (cdr timestamp-and-value)
>          (let ((new-value (progn
>                             ,@body
>                             )))
>            (put ',func 'yas--condition-cache (cons yas--condition-cache-timestamp new-value))
>            new-value)))))
1828c2200,2201
< (defun yas/expand ()
---
> (defalias 'yas-expand 'yas-expand-from-trigger-key)
> (defun yas-expand-from-trigger-key (&optional field)
1832c2205,2208
< defined in `yas/fallback-behavior'"
---
> defined in `yas-fallback-behavior'.
> 
> Optional argument FIELD is for non-interactive use and is an
> object satisfying `yas--field-p' to restrict the expansion to."
1834c2210,2228
<   (yas/expand-1))
---
>   (setq yas--condition-cache-timestamp (current-time))
>   (let (templates-and-pos)
>     (unless (and yas-expand-only-for-last-commands
>                  (not (member last-command yas-expand-only-for-last-commands)))
>       (setq templates-and-pos (if field
>                                   (save-restriction
>                                     (narrow-to-region (yas--field-start field)
>                                                       (yas--field-end field))
>                                     (yas--current-key))
>                                 (yas--current-key))))
>     (if (and templates-and-pos
>              (first templates-and-pos))
>         (yas--expand-or-prompt-for-template (first templates-and-pos)
>                                            (second templates-and-pos)
>                                            (third templates-and-pos))
>       (yas--fallback 'trigger-key))))
> 
> (defun yas-expand-from-keymap ()
>   "Directly expand some snippets, searching `yas--direct-keymaps'.
1836,1842c2230,2239
< (defun yas/expand-1 (&optional field)
<   "Actually fo the work for `yas/expand'"
<   (multiple-value-bind (templates start end) (if field
<                                                  (save-restriction
<                                                    (narrow-to-region (yas/field-start field) (yas/field-end field))
<                                                    (yas/current-key))
<                                                (yas/current-key))
---
> If expansion fails, execute the previous binding for this key"
>   (interactive)
>   (setq yas--condition-cache-timestamp (current-time))
>   (let* ((yas--prefix current-prefix-arg)
>          (vec (subseq (this-command-keys-vector) (if current-prefix-arg
>                                                      universal-argument-num-events
>                                                    0)))
>          (templates (mapcan #'(lambda (table)
>                                 (yas--fetch table vec))
>                             (yas--get-snippet-tables))))
1844,1881c2241,2314
<         (let ((template (or (and (rest templates) ;; more than one
<                                  (yas/prompt-for-template (mapcar #'cdr templates)))
<                             (cdar templates))))
<           (when template
<             (yas/expand-snippet (yas/template-content template)
<                                 start
<                                 end
<                                 (yas/template-expand-env template))))
<       (cond ((eq yas/fallback-behavior 'return-nil)
<              ;; return nil
<              nil)
<             ((eq yas/fallback-behavior 'call-other-command)
<              (let* ((yas/minor-mode nil)
<                     (keys-1 (this-command-keys-vector))
<                     (keys-2 (and yas/trigger-key
<                                  (stringp yas/trigger-key)
<                                  (read-kbd-macro yas/trigger-key))) 
<                     (command-1 (and keys-1 (key-binding keys-1)))
<                     (command-2 (and keys-2 (key-binding keys-2)))
<                     (command (or (and (not (eq command-1 'yas/expand))
<                                       command-1)
<                                  command-2)))
<                (when (and (commandp command)
<                           (not (eq 'yas/expand command)))
<                  (setq this-command command)
<                  (call-interactively command))))
<             ((and (listp yas/fallback-behavior)
<                   (cdr yas/fallback-behavior)
<                   (eq 'apply (car yas/fallback-behavior)))
<              (if (cddr yas/fallback-behavior)
<                  (apply (cadr yas/fallback-behavior)
<                         (cddr yas/fallback-behavior))
<                (when (commandp (cadr yas/fallback-behavior))
<                  (setq this-command (cadr yas/fallback-behavior))
<                  (call-interactively (cadr yas/fallback-behavior)))))
<             (t
<              ;; also return nil if all the other fallbacks have failed
<              nil)))))
---
>         (yas--expand-or-prompt-for-template templates)
>       (let ((yas-fallback-behavior 'call-other-command))
>         (yas--fallback)))))
> 
> (defun yas--expand-or-prompt-for-template (templates &optional start end)
>   "Expand one of TEMPLATES from START to END.
> 
> Prompt the user if TEMPLATES has more than one element, else
> expand immediately. Common gateway for
> `yas-expand-from-trigger-key' and `yas-expand-from-keymap'."
>   (let ((yas--current-template (or (and (rest templates) ;; more than one
>                                        (yas--prompt-for-template (mapcar #'cdr templates)))
>                                   (cdar templates))))
>     (when yas--current-template
>       (yas-expand-snippet (yas--template-content yas--current-template)
>                           start
>                           end
>                           (yas--template-expand-env yas--current-template)))))
> 
> (defun yas--trigger-key-for-fallback ()
>   ;; When `yas-trigger-key' is <tab> it correctly overrides
>   ;; org-mode's <tab>, for example and searching for fallbacks
>   ;; correctly returns `org-cycle'. However, most other modes bind
>   ;; "TAB" (which is translated from <tab>), and calling
>   ;; (key-binding "TAB") does not place return that command into
>   ;; our command-2 local. So we cheat.
>   ;;
>   (if (string= yas-trigger-key "<tab>")
>       "TAB"
>     yas-trigger-key))
> 
> (defun yas--fallback (&optional from-trigger-key-p)
>   "Fallback after expansion has failed.
> 
> Common gateway for `yas-expand-from-trigger-key' and
> `yas-expand-from-keymap'."
>   (cond ((eq yas-fallback-behavior 'return-nil)
>          ;; return nil
>          nil)
>         ((eq yas-fallback-behavior 'call-other-command)
>          (let* ((yas-minor-mode nil)
>                 (yas--direct-keymaps nil)
>                 (yas-trigger-key (yas--trigger-key-for-fallback))
>                 (keys-1 (this-command-keys-vector))
>                 (keys-2 (and yas-trigger-key
>                              from-trigger-key-p
>                              (stringp yas-trigger-key)
>                              (read-kbd-macro yas-trigger-key)))
>                 (command-1 (and keys-1 (key-binding keys-1)))
>                 (command-2 (and keys-2 (key-binding keys-2)))
>                 ;; An (ugly) safety: prevents infinite recursion of
>                 ;; yas-expand* calls.
>                 (command (or (and (symbolp command-1)
>                                   (not (string-match "yas-expand" (symbol-name command-1)))
>                                   command-1)
>                              (and (symbolp command-2)
>                                   command-2))))
>            (when (and (commandp command)
>                       (not (string-match "yas-expand" (symbol-name command))))
>              (setq this-command command)
>              (call-interactively command))))
>         ((and (listp yas-fallback-behavior)
>               (cdr yas-fallback-behavior)
>               (eq 'apply (car yas-fallback-behavior)))
>          (if (cddr yas-fallback-behavior)
>              (apply (cadr yas-fallback-behavior)
>                     (cddr yas-fallback-behavior))
>            (when (commandp (cadr yas-fallback-behavior))
>              (setq this-command (cadr yas-fallback-behavior))
>              (call-interactively (cadr yas-fallback-behavior)))))
>         (t
>          ;; also return nil if all the other fallbacks have failed
>          nil)))
> 
1884,1885c2317
< ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
< ;;; Snippet development
---
> ;;; Utils for snippet development:
1887,1888c2319,2320
< (defun yas/all-templates (tables)
<   "Return all snippet tables applicable for the current buffer.
---
> (defun yas--all-templates (tables)
>   "Get `yas--template' objects in TABLES, applicable for buffer and point.
1890,1893c2322,2325
< Honours `yas/choose-tables-first', `yas/choose-keys-first' and
< `yas/buffer-local-condition'"
<   (when yas/choose-tables-first
<     (setq tables (list (yas/prompt-for-table tables))))
---
> Honours `yas-choose-tables-first', `yas-choose-keys-first' and
> `yas-buffer-local-condition'"
>   (when yas-choose-tables-first
>     (setq tables (list (yas--prompt-for-table tables))))
1895,1897c2327,2329
<           (if yas/choose-keys-first
<               (let ((key (yas/prompt-for-keys
<                           (mapcan #'yas/snippet-table-all-keys tables))))
---
>           (if yas-choose-keys-first
>               (let ((key (yas--prompt-for-keys
>                           (mapcan #'yas--table-all-keys tables))))
1900c2332
<                               (yas/fetch table key))
---
>                               (yas--fetch table key))
1902c2334,2335
<             (mapcan #'yas/snippet-table-templates tables))))
---
>             (remove-duplicates (mapcan #'yas--table-templates tables)
>                                :test #'equal))))
1904c2337
< (defun yas/insert-snippet (&optional no-condition)
---
> (defun yas-insert-snippet (&optional no-condition)
1906c2339
< to `yas/prompt-function'.
---
> to `yas--prompt-function'.
1911c2344,2345
<   (let* ((yas/buffer-local-condition (or (and no-condition
---
>   (setq yas--condition-cache-timestamp (current-time))
>   (let* ((yas-buffer-local-condition (or (and no-condition
1913,1919c2347,2353
<                                          yas/buffer-local-condition))
<          (templates (yas/all-templates (yas/get-snippet-tables)))
<          (template (and templates
<                         (or (and (rest templates) ;; more than one template for same key
<                                  (yas/prompt-for-template templates))
<                             (car templates))))
<          (where (if mark-active
---
>                                          yas-buffer-local-condition))
>          (templates (yas--all-templates (yas--get-snippet-tables)))
>          (yas--current-template (and templates
>                                     (or (and (rest templates) ;; more than one template for same key
>                                              (yas--prompt-for-template templates))
>                                         (car templates))))
>          (where (if (region-active-p)
1922,1923c2356,2357
<     (if template
<         (yas/expand-snippet (yas/template-content template)
---
>     (if yas--current-template
>         (yas-expand-snippet (yas--template-content yas--current-template)
1926,1927c2360,2361
<                             (yas/template-expand-env template))
<       (message "[yas] No snippets can be inserted here!"))))
---
>                             (yas--template-expand-env yas--current-template))
>       (yas--message 3 "No snippets can be inserted here!"))))
1929,1930c2363,2364
< (defun yas/visit-snippet-file ()
<   "Choose a snippet to edit, selection like `yas/insert-snippet'.
---
> (defun yas-visit-snippet-file ()
>   "Choose a snippet to edit, selection like `yas-insert-snippet'.
1935,1936c2369,2371
<   (let* ((yas/buffer-local-condition 'always)
<          (templates (yas/all-templates (yas/get-snippet-tables)))
---
>   (let* ((yas-buffer-local-condition 'always)
>          (templates (yas--all-templates (yas--get-snippet-tables)))
>          (yas-prompt-functions '(yas-ido-prompt yas-completing-prompt))
1938,1940c2373,2374
<                         (or (and (rest templates) ;; more than one template for same key
<                                  (yas/prompt-for-template templates
<                                                           "Choose a snippet template to edit: "))
---
>                         (or (yas--prompt-for-template templates
>                                                      "Choose a snippet template to edit: ")
1943,1944c2377,2379
<     (when template
<       (yas/visit-snippet-file-1 template))))
---
>     (if template
>         (yas--visit-snippet-file-1 template)
>       (message "No snippets tables active!"))))
1946,1948c2381,2383
< (defun yas/visit-snippet-file-1 (template)
<   (let ((file (yas/template-file template)))
<     (cond ((and file (file-exists-p file))
---
> (defun yas--visit-snippet-file-1 (template)
>   (let ((file (yas--template-file template)))
>     (cond ((and file (file-readable-p file))
1950c2385,2386
<            (snippet-mode))
---
>            (snippet-mode)
>            (set (make-local-variable 'yas--editing-template) template))
1954,1960c2390,2412
<            (message "This snippet was not loaded from a file!")))))
< 
< (defun yas/guess-snippet-directories-1 (table &optional suffix)
<   "Guesses possible snippet subdirsdirectories for TABLE."
<   (unless suffix
<     (setq suffix (yas/snippet-table-name table))) 
<   (cons suffix
---
>            (switch-to-buffer (format "*%s*"(yas--template-name template)))
>            (let ((type 'snippet))
>              (when (listp (yas--template-content template))
>                (insert (format "# type: command\n"))
>                (setq type 'command))
>              (insert (format "# key: %s\n" (yas--template-key template)))
>              (insert (format "# name: %s\n" (yas--template-name template)))
>              (when (yas--template-keybinding template)
>                (insert (format "# binding: %s\n" (yas--template-keybinding template))))
>              (when (yas--template-expand-env template)
>                (insert (format "# expand-env: %s\n" (yas--template-expand-env template))))
>              (when (yas--template-condition template)
>                (insert (format "# condition: %s\n" (yas--template-condition template))))
>              (insert "# --\n")
>              (insert (if (eq type 'command)
>                          (pp-to-string (yas--template-content template))
>                        (yas--template-content template))))
>            (snippet-mode)
>            (set (make-local-variable 'yas--editing-template) template)))))
> 
> (defun yas--guess-snippet-directories-1 (table)
>   "Guesses possible snippet subdirectories for TABLE."
>   (cons (yas--table-name table)
1962,1965c2414,2416
<                     (yas/guess-snippet-directories-1
<                      parent
<                      (concat (yas/snippet-table-name parent) "/" suffix)))
<                 (yas/snippet-table-parents table))))
---
>                     (yas--guess-snippet-directories-1
>                      parent))
>                 (yas--table-parents table))))
1967c2418
< (defun yas/guess-snippet-directories ()
---
> (defun yas--guess-snippet-directories (&optional table)
1969c2420,2436
< tables.
---
> tables (or optional TABLE).
> 
> Returns a list of elemts (TABLE . DIRS) where TABLE is a
> `yas--table' object and DIRS is a list of all possible directories
> where snippets of table might exist."
>   (let ((main-dir (replace-regexp-in-string
>                    "/+$" ""
>                    (or (first (or (yas-snippet-dirs)
>                                   (setq yas-snippet-dirs '("~/.emacs.d/snippets")))))))
>         (tables (or (and table
>                          (list table))
>                     (yas--get-snippet-tables))))
>     ;; HACK! the snippet table created here is actually registered!
>     ;;
>     (unless (or table (gethash major-mode yas--tables))
>       (push (yas--table-get-create major-mode)
>             tables))
1971,1988d2437
< Returns a a list of options alist TABLE -> DIRS where DIRS are
< all the possibly directories where snippets of table might be
< lurking."
<   (let ((main-dir (or (and (listp yas/root-directory)
<                            (first yas/root-directory))
<                       yas/root-directory
<                       (setq yas/root-directory "~/.emacs.d/snippets")))
<         (tables (yas/get-snippet-tables)))
<     ;; HACK! the snippet table created here is a dummy table that
<     ;; holds the correct name so that `yas/make-directory-maybe' can
<     ;; work. The real table, if it does not exist in
<     ;; yas/snippet-tables will be created when the first snippet for
<     ;; that mode is loaded.
<     ;; 
<     (unless (gethash major-mode yas/snippet-tables)
<       (setq tables (cons (yas/make-snippet-table (symbol-name major-mode))
<                          tables)))
<     
1993c2442
<                               (yas/guess-snippet-directories-1 table))))
---
>                               (yas--guess-snippet-directories-1 table))))
1996c2445
< (defun yas/make-directory-maybe (table-and-dirs &optional main-table-string)
---
> (defun yas--make-directory-maybe (table-and-dirs &optional main-table-string)
1999a2449,2450
>         (unless (file-writable-p (file-name-directory candidate))
>           (error (yas--format "%s is not writable." candidate)))
2002,2003c2453,2454
<                               (if (gethash (intern (yas/snippet-table-name (car table-and-dirs)))
<                                            yas/snippet-tables)
---
>                               (if (gethash (yas--table-mode (car table-and-dirs))
>                                            yas--tables)
2008c2459
<                               (yas/snippet-table-name (car table-and-dirs))))
---
>                               (yas--table-name (car table-and-dirs))))
2014,2015c2465,2469
< (defun yas/new-snippet (&optional choose-instead-of-guess)
<   ""
---
> (defun yas-new-snippet (&optional no-template)
>   "Pops a new buffer for writing a snippet.
> 
> Expands a snippet-writing snippet, unless the optional prefix arg
> NO-TEMPLATE is non-nil."
2017,2052c2471,2481
<   (let* ((guessed-directories (yas/guess-snippet-directories))
<          (option (or (and choose-instead-of-guess
<                           (some #'(lambda (fn)
<                                     (funcall fn "Choose a snippet table: "
<                                              guessed-directories
<                                              #'(lambda (option)
<                                                  (yas/snippet-table-name (car option)))))
<                                 yas/prompt-functions))
<                      (first guessed-directories)))
<          (chosen))
<     (setq chosen (yas/make-directory-maybe option (unless choose-instead-of-guess
<                                                     " main")))
<     (unless (or chosen
<                 choose-instead-of-guess)
<       (if (y-or-n-p (format "Continue guessing for other active tables %s? "
<                             (mapcar #'(lambda (table-and-dirs)
<                                         (yas/snippet-table-name (car table-and-dirs)))
<                                     (rest guessed-directories))))
<           (setq chosen (some #'yas/make-directory-maybe
<                              (rest guessed-directories)))))
<     (unless (or chosen
<                 choose-instead-of-guess)
<       (when (y-or-n-p "Having trouble... use snippet root dir? ")
<         (setq chosen (if (listp yas/root-directory)
<                          (first yas/root-directory)
<                        yas/root-directory))))
<     (if chosen
<         (let ((default-directory chosen)
<               (name (read-from-minibuffer "Enter a snippet name: ")))
<           (find-file-other-window (concat name
<                                           ".yasnippet"))
<           (snippet-mode)
<           (unless (and choose-instead-of-guess
<                        (not (y-or-n-p "Insert a snippet with useful headers? ")))
<             (yas/expand-snippet (format 
<                                  "\
---
>   (let ((guessed-directories (yas--guess-snippet-directories)))
> 
>     (switch-to-buffer "*new snippet*")
>     (erase-buffer)
>     (kill-all-local-variables)
>     (snippet-mode)
>     (yas-minor-mode 1)
>     (set (make-local-variable 'yas--guessed-modes) (mapcar #'(lambda (d)
>                                                               (yas--table-mode (car d)))
>                                                           guessed-directories))
>     (unless no-template (yas-expand-snippet "\
2054,2057c2483,2487
< # name: %s
< # key: $1${2:
< # binding: \"${3:keybinding}\"}${4:
< # expand-env: ((${5:some-var} ${6:some-value}))}
---
> # name: $1
> # key: ${2:${1:$(replace-regexp-in-string \"\\\\\\\\(\\\\\\\\w+\\\\\\\\).*\" \"\\\\\\\\1\" yas-text)}}${3:
> # binding: ${4:direct-keybinding}}${5:
> # expand-env: ((${6:some-var} ${7:some-value}))}${8:
> # type: command}
2059,2063c2489
< $0" name))))
<       (message "[yas] aborted snippet creation."))))
< 
< (defun yas/find-snippets (&optional same-window )
<   "Look for user snippets in guessed current mode's directory.
---
> $0"))))
2065c2491,2494
< Calls `find-file' interactively in the guessed directory.
---
> (defun yas--compute-major-mode-and-parents (file)
>   "Given FILE, find the nearest snippet directory for a given
> mode, then return a list (MODE-SYM PARENTS), the mode's symbol and a list
> representing one or more of the mode's parents.
2067,2106c2496,2497
< With prefix arg SAME-WINDOW opens the buffer in the same window.
< 
< Because snippets can be loaded from many different locations,
< this has to guess the correct directory using
< `yas/guess-snippet-directories', which returns a list of
< options. 
< 
< If any one of these exists, it is taken and `find-file' is called
< there, otherwise, proposes to create the first option returned by
< `yas/guess-snippet-directories'."
<   (interactive "P")
<   (let* ((guessed-directories (yas/guess-snippet-directories))
<          (chosen)
<          (buffer))
<     (setq chosen (yas/make-directory-maybe (first guessed-directories) " main"))
<     (unless chosen
<       (if (y-or-n-p (format "Continue guessing for other active tables %s? "
<                             (mapcar #'(lambda (table-and-dirs)
<                                         (yas/snippet-table-name (car table-and-dirs)))
<                                     (rest guessed-directories))))
<           (setq chosen (some #'yas/make-directory-maybe
<                              (rest guessed-directories)))))
<     (unless chosen
<       (when (y-or-n-p "Having trouble... go to snippet root dir? ")
<         (setq chosen (if (listp yas/root-directory)
<                          (first yas/root-directory)
<                        yas/root-directory))))
<     (if chosen
<         (let ((default-directory chosen))
<           (setq buffer (call-interactively (if same-window
<                                                'find-file
<                                              'find-file-other-window)))
<           (when buffer
<             (save-excursion
<               (set-buffer buffer)
<               (when (eq major-mode 'fundamental-mode)
<                 (snippet-mode)))))
<       (message "Could not guess snippet dir!"))))
< 
< (defun yas/compute-major-mode-and-parents (file &optional prompt-if-failed no-hierarchy-parents)
---
> Note that MODE-SYM need not be the symbol of a real major mode,
> neither do the elements of PARENTS."
2108c2499,2503
<                         (directory-file-name (or (locate-dominating-file file ".yas-make-groups")
---
>                         (directory-file-name (or (some #'(lambda (special)
>                                                            (locate-dominating-file file special))
>                                                        '(".yas-setup.el"
>                                                          ".yas-make-groups"
>                                                          ".yas-parents"))
2109a2505
>          (parents-file-name (concat file-dir "/.yas-parents"))
2112,2116d2507
<          (parent-file-dir (and file-dir
<                                (directory-file-name (file-name-directory file-dir))))
<          (parent-mode-name (and parent-file-dir
<                                 (not no-hierarchy-parents)
<                                 (file-name-nondirectory parent-file-dir)))
2118,2125c2509,2510
<                                   (intern major-mode-name))
<                              (when prompt-if-failed
<                                (read-from-minibuffer
<                                 "[yas] Cannot auto-detect major mode! Enter a major mode: "))))
<          (parent-mode-sym (and parent-mode-name
<                                (intern parent-mode-name)))
<          (extra-parents-file-name (concat file-dir "/.yas-parents"))
<          (more-parents (when (file-readable-p extra-parents-file-name)
---
>                                   (intern major-mode-name))))
>          (parents (when (file-readable-p parents-file-name)
2129c2514
<                                     (insert-file-contents extra-parents-file-name)
---
>                                     (insert-file-contents parents-file-name)
2133,2134c2518
<       (remove nil (append (list major-mode-sym parent-mode-sym)
<                           more-parents)))))
---
>       (cons major-mode-sym parents))))
2136,2137c2520,2521
< (defun yas/load-snippet-buffer (&optional kill)
<   "Parse and load current buffer's snippet definition.
---
> (defvar yas--editing-template nil
>   "Supporting variable for `yas-load-snippet-buffer' and `yas--visit-snippet'")
2139,2161c2523,2524
< With optional prefix argument KILL quit the window and buffer."
<   (interactive "P")
<   (if buffer-file-name
<       (let ((major-mode-and-parent (yas/compute-major-mode-and-parents buffer-file-name)))
<         (if major-mode-and-parent
<             (let* ((parsed (yas/parse-template buffer-file-name))
<                    (name (and parsed
<                               (third parsed))))
<               (when name
<                 (let ((yas/better-guess-for-replacements t))
<                   (yas/define-snippets (car major-mode-and-parent)
<                                        (list parsed)
<                                        (cdr major-mode-and-parent)))
<                 (when (and (buffer-modified-p)
<                            (y-or-n-p "Save snippet? "))
<                   (save-buffer))
<                 (if kill
<                     (quit-window kill)
<                   (message "[yas] Snippet \"%s\" loaded for %s."
<                            name
<                            (car major-mode-and-parent)))))
<           (message "[yas] Cannot load snippet for unknown major mode")))
<     (message "Save the buffer as a file first!")))
---
> (defvar yas--current-template nil
>   "Holds the current template being expanded into a snippet.")
2163c2526,2607
< (defun yas/tryout-snippet (&optional debug)
---
> (defvar yas--guessed-modes nil
>   "List of guessed modes supporting `yas-load-snippet-buffer'.")
> 
> (defun yas--read-table ()
>   "Ask user for a snippet table, help with some guessing."
>   (let ((prompt (if (and (featurep 'ido)
>                          ido-mode)
>                     'ido-completing-read 'completing-read)))
>     (unless yas--guessed-modes
>       (set (make-local-variable 'yas--guessed-modes)
>            (or (yas--compute-major-mode-and-parents buffer-file-name))))
>     (intern
>      (funcall prompt (format "Choose or enter a table (yas guesses %s): "
>                              (if yas--guessed-modes
>                                  (first yas--guessed-modes)
>                                "nothing"))
>               (mapcar #'symbol-name yas--guessed-modes)
>               nil
>               nil
>               nil
>               nil
>               (if (first yas--guessed-modes)
>                   (symbol-name (first yas--guessed-modes)))))))
> 
> (defun yas-load-snippet-buffer (table &optional interactive)
>   "Parse and load current buffer's snippet definition into TABLE.
> 
> TABLE is a symbol naming a passed to `yas--table-get-create'.
> 
> When called interactively, prompt for the table name and
> whether (and where) to save the snippet, then quit the window."
>   (interactive (list (yas--read-table) t))
>   (cond
>    ;;  We have `yas--editing-template', this buffer's content comes from a
>    ;;  template which is already loaded and neatly positioned,...
>    ;;
>    (yas--editing-template
>     (yas-define-snippets-1 (yas--parse-template (yas--template-file yas--editing-template))
>                            (yas--template-table yas--editing-template)))
>    ;; Try to use `yas--guessed-modes'. If we don't have that use the
>    ;; value from `yas--compute-major-mode-and-parents'
>    ;;
>    (t
>     (unless yas--guessed-modes
>       (set (make-local-variable 'yas--guessed-modes) (or (yas--compute-major-mode-and-parents buffer-file-name))))
>     (let* ((table (yas--table-get-create table)))
>       (set (make-local-variable 'yas--editing-template)
>            (yas-define-snippets-1 (yas--parse-template buffer-file-name)
>                                   table)))))
> 
>   (when (and interactive
>              (or
>               ;; Only offer to save this if it looks like a library or new
>               ;; snippet (loaded from elisp, from a dir in `yas-snippet-dirs'
>               ;; which is not the first, or from an unwritable file)
>               ;;
>               (not (yas--template-file yas--editing-template))
>               (not (file-writable-p (yas--template-file yas--editing-template)))
>               (and (listp yas-snippet-dirs)
>                    (second yas-snippet-dirs)
>                    (not (string-match (expand-file-name (first yas-snippet-dirs))
>                                       (yas--template-file yas--editing-template)))))
>              (y-or-n-p (yas--format "Looks like a library or new snippet. Save to new file? ")))
>     (let* ((option (first (yas--guess-snippet-directories (yas--template-table yas--editing-template))))
>            (chosen (and option
>                         (yas--make-directory-maybe option))))
>       (when chosen
>         (let ((default-file-name (or (and (yas--template-file yas--editing-template)
>                                           (file-name-nondirectory (yas--template-file yas--editing-template)))
>                                      (yas--template-name yas--editing-template))))
>           (write-file (concat chosen "/"
>                               (read-from-minibuffer (format "File name to create in %s? " chosen)
>                                                     default-file-name)))
>           (setf (yas--template-file yas--editing-template) buffer-file-name)))))
>   (when interactive
>     (quit-window interactive)
>     (yas--message 3 "Snippet \"%s\" loaded for %s."
>                   (yas--template-name yas--editing-template)
>                   (yas--table-name (yas--template-table yas--editing-template)))))
> 
> 
> (defun yas-tryout-snippet (&optional debug)
2166,2167c2610,2611
<   (let* ((major-mode-and-parent (yas/compute-major-mode-and-parents buffer-file-name))
<          (parsed (yas/parse-template))
---
>   (let* ((major-mode-and-parent (yas--compute-major-mode-and-parents buffer-file-name))
>          (parsed (yas--parse-template))
2171,2183c2615,2629
<                         (intern (read-from-minibuffer "[yas] please input a mode: "))))
<          (template (and parsed
<                         (fboundp test-mode)
<                         (yas/make-template (second parsed)
<                                            (third parsed)
<                                            nil
<                                            (sixth parsed)
<                                            nil
<                                            nil))))
<     (cond (template
<            (let ((buffer-name (format "*YAS TEST: %s*" (yas/template-name template))))
<              (set-buffer (switch-to-buffer buffer-name))
<              (erase-buffer)
---
>                         (first yas--guessed-modes)
>                         (intern (read-from-minibuffer (yas--format "Please input a mode: ")))))
>          (yas--current-template
>           (and parsed
>                (fboundp test-mode)
>                (yas--populate-template (yas--make-blank-template)
>                                       :table       nil ;; no tables for ephemeral snippets
>                                       :key         (first parsed)
>                                       :content     (second parsed)
>                                       :name        (third parsed)
>                                       :expand-env  (sixth parsed)))))
>     (cond (yas--current-template
>            (let ((buffer-name (format "*testing snippet: %s*" (yas--template-name yas--current-template))))
>              (kill-buffer (get-buffer-create buffer-name))
>              (switch-to-buffer (get-buffer-create buffer-name))
2185,2186c2631,2634
<              (funcall test-mode)
<              (yas/expand-snippet (yas/template-content template)
---
>              (condition-case nil (funcall test-mode) (error nil))
> 	     (yas-minor-mode 1)
>              (setq buffer-read-only nil)
>              (yas-expand-snippet (yas--template-content yas--current-template)
2189,2191c2637,2640
<                                  (yas/template-expand-env template))
<              (when debug
<                (add-hook 'post-command-hook 'yas/debug-snippet-vars 't 'local))))
---
>                                  (yas--template-expand-env yas--current-template))
>              (when (and debug
>                         (require 'yasnippet-debug nil t))
>                (add-hook 'post-command-hook 'yas-debug-snippet-vars nil t))))
2193c2642,2756
<            (message "[yas] Cannot test snippet for unknown major mode")))))
---
>            (yas--message 3 "Cannot test snippet for unknown major mode")))))
> 
> (defun yas-active-keys ()
>   "Return all active trigger keys for current buffer and point"
>   (remove-duplicates (mapcan #'yas--table-all-keys (yas--get-snippet-tables))
>                      :test #'string=))
> 
> (defun yas--template-fine-group (template)
>   (car (last (or (yas--template-group template)
>                  (yas--template-perm-group template)))))
> 
> (defun yas-describe-tables (&optional choose)
>   "Display snippets for each table."
>   (interactive "P")
>   (let* ((by-name-hash (and choose
>                             (y-or-n-p "Show by namehash? ")))
>          (buffer (get-buffer-create "*YASnippet tables*"))
>          (active-tables (yas--get-snippet-tables))
>          (remain-tables (let ((all))
>                           (maphash #'(lambda (k v)
>                                        (unless (find v active-tables)
>                                          (push v all)))
>                                    yas--tables)
>                           all))
>          (table-lists (list active-tables remain-tables))
>          (original-buffer (current-buffer))
>          (continue t)
>          (yas--condition-cache-timestamp (current-time)))
>     (with-current-buffer buffer
>       (setq buffer-read-only nil)
>       (erase-buffer)
>       (cond ((not by-name-hash)
>              (insert "YASnippet tables: \n")
>              (while (and table-lists
>                          continue)
>                (dolist (table (car table-lists))
>                  (yas--describe-pretty-table table original-buffer))
>                (setq table-lists (cdr table-lists))
>                (when table-lists
>                  (yas--create-snippet-xrefs)
>                  (display-buffer buffer)
>                  (setq continue (and choose (y-or-n-p "Show also non-active tables? ")))))
>              (yas--create-snippet-xrefs)
>              (help-mode)
>              (goto-char 1))
>             (t
>              (insert "\n\nYASnippet tables by NAMEHASH: \n")
>              (dolist (table (append active-tables remain-tables))
>                (insert (format "\nSnippet table `%s':\n\n" (yas--table-name table)))
>                (let ((keys))
>                  (maphash #'(lambda (k v)
>                               (push k keys))
>                           (yas--table-hash table))
>                  (dolist (key keys)
>                    (insert (format "   key %s maps snippets: %s\n" key
>                                    (let ((names))
>                                      (maphash #'(lambda (k v)
>                                                   (push k names))
>                                               (gethash key (yas--table-hash table)))
>                                      names))))))))
>       (goto-char 1)
>       (setq buffer-read-only t))
>     (display-buffer buffer)))
> 
> (defun yas--describe-pretty-table (table &optional original-buffer)
>   (insert (format "\nSnippet table `%s'"
>                   (yas--table-name table)))
>   (if (yas--table-parents table)
>       (insert (format " parents: %s\n"
>                       (mapcar #'yas--table-name
>                               (yas--table-parents table))))
>     (insert "\n"))
>   (insert (make-string 100 ?-) "\n")
>   (insert "group                   state name                                    key             binding\n")
>   (let ((groups-hash (make-hash-table :test #'equal)))
>     (maphash #'(lambda (k v)
>                  (let ((group (or (yas--template-fine-group v)
>                                   "(top level)")))
>                    (when (yas--template-name v)
>                      (puthash group
>                               (cons v (gethash group groups-hash))
>                               groups-hash))))
>              (yas--table-uuidhash table))
>     (maphash
>      #'(lambda (group templates)
>          (setq group (truncate-string-to-width group 25 0 ?  "..."))
>          (insert (make-string 100 ?-) "\n")
>          (dolist (p templates)
>            (let ((name (truncate-string-to-width (propertize (format "\\\\snippet `%s'" (yas--template-name p))
>                                                              'yasnippet p)
>                                                  50 0 ? "..."))
>                  (group (prog1 group
>                           (setq group (make-string (length group) ? ))))
>                  (condition-string (let ((condition (yas--template-condition p)))
>                                      (if (and condition
>                                               original-buffer)
>                                          (with-current-buffer original-buffer
>                                            (if (yas--eval-condition condition)
>                                                "(y)"
>                                              "(s)"))
>                                        "(a)"))))
>              (insert group " ")
>              (insert condition-string " ")
>              (insert name
>                      (if (string-match "\\.\\.\\.$" name)
>                          "'"
>                        " ")
>                      " ")
>              (insert (truncate-string-to-width (or (yas--template-key p) "")
>                                                15 0 ?  "...") " ")
>              (insert (truncate-string-to-width (key-description (yas--template-keybinding p))
>                                                15 0 ?  "...") " ")
>              (insert "\n"))))
>      groups-hash)))
> 
2196d2758
< ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2199c2761
< (defvar yas/modified-p nil
---
> (defvar yas-modified-p nil
2202c2764
< (defvar yas/moving-away-p nil
---
> (defvar yas-moving-away-p nil
2205c2767
< (defvar yas/text nil
---
> (defvar yas-text nil
2208c2770
< (defun yas/substr (str pattern &optional subexp)
---
> (defun yas-substr (str pattern &optional subexp)
2219,2222c2781,2790
< (defun yas/choose-value (possibilities)
<   "Prompt for a string in the list POSSIBILITIES and return it."
<   (unless (or yas/moving-away-p
<               yas/modified-p)
---
> (defun yas-choose-value (&rest possibilities)
>   "Prompt for a string in POSSIBILITIES and return it.
> 
> The last element of POSSIBILITIES may be a list of strings."
>   (unless (or yas-moving-away-p
>               yas-modified-p)
>     (setq possibilities (nreverse possibilities))
>     (setq possibilities (if (listp (car possibilities))
>                             (append (reverse (car possibilities)) (rest possibilities))
>                                    possibilities))
2225c2793
<           yas/prompt-functions)))
---
>           yas-prompt-functions)))
2227c2795
< (defun yas/key-to-value (alist)
---
> (defun yas-key-to-value (alist)
2229,2230c2797,2798
<   (unless (or yas/moving-away-p
<               yas/modified-p)
---
>   (unless (or yas-moving-away-p
>               yas-modified-p)
2236,2238c2804,2806
< (defun yas/throw (text)
<   "Throw a yas/exception with TEXT as the reason."
<   (throw 'yas/exception (cons 'yas/exception text)))
---
> (defun yas-throw (text)
>   "Throw a yas--exception with TEXT as the reason."
>   (throw 'yas--exception (cons 'yas--exception text)))
2240c2808
< (defun yas/verify-value (possibilities)
---
> (defun yas-verify-value (possibilities)
2244,2245c2812,2813
<   (when (and yas/moving-away-p (notany #'(lambda (pos) (string= pos yas/text)) possibilities))
<     (yas/throw (format "[yas] field only allows %s" possibilities))))
---
>   (when (and yas-moving-away-p (notany #'(lambda (pos) (string= pos yas-text)) possibilities))
>     (yas-throw (yas--format "Field only allows %s" possibilities))))
2247,2248c2815,2819
< (defun yas/field-value (number)
<   (let* ((snippet (car (yas/snippets-at-point)))
---
> (defun yas-field-value (number)
>   "Get the string for field with NUMBER.
> 
> Use this in primary and mirror transformations to tget."
>   (let* ((snippet (car (yas--snippets-at-point)))
2250c2821
<                      (yas/snippet-find-field snippet number))))
---
>                      (yas--snippet-find-field snippet number))))
2252c2823
<       (yas/field-text-for-display field))))
---
>       (yas--field-text-for-display field))))
2254,2256c2825,2845
< (defun yas/default-from-field (number)
<   (unless yas/modified-p
<     (yas/field-value number)))
---
> (defun yas-text ()
>   "Return `yas-text' if that exists and is non-empty, else nil."
>   (if (and yas-text
>            (not (string= "" yas-text)))
>       yas-text))
> 
> (defun yas-selected-text ()
>   "Return `yas-selected-text' if that exists and is non-empty, else nil."
>   (if (and yas-selected-text
>            (not (string= "" yas-selected-text)))
>       yas-selected-text))
> 
> (defun yas--get-field-once (number &optional transform-fn)
>   (unless yas-modified-p
>     (if transform-fn
>         (funcall transform-fn (yas-field-value number))
>       (yas-field-value number))))
> 
> (defun yas-default-from-field (number)
>   (unless yas-modified-p
>     (yas-field-value number)))
2258c2847
< (defun yas/inside-string ()
---
> (defun yas-inside-string ()
2260a2850,2857
> (defun yas-unimplemented (&optional missing-feature)
>   (if yas--current-template
>       (if (y-or-n-p (format "This snippet is unimplemented (missing %s) Visit the snippet definition? "
>                             (or missing-feature
>                                 "something")))
>           (yas--visit-snippet-file-1 yas--current-template))
>     (message "No implementation. Missing %s" (or missing-feature "something"))))
> 
2262d2858
< ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2265c2861
< (defvar yas/active-field-overlay nil
---
> (defvar yas--active-field-overlay nil
2268c2864
< (defvar yas/field-protection-overlays nil
---
> (defvar yas--field-protection-overlays nil
2271c2867
< (defconst yas/prefix nil
---
> (defconst yas--prefix nil
2274,2277c2870
< (defvar yas/deleted-text nil
<   "The text deleted in the last snippet expansion.")
< 
< (defvar yas/selected-text nil
---
> (defvar yas-selected-text nil
2280c2873
< (defvar yas/start-column nil
---
> (defvar yas--start-column nil
2283,2285c2876,2879
< (make-variable-buffer-local 'yas/active-field-overlay)
< (make-variable-buffer-local 'yas/field-protection-overlays)
< (make-variable-buffer-local 'yas/deleted-text)
---
> (make-variable-buffer-local 'yas--active-field-overlay)
> (make-variable-buffer-local 'yas--field-protection-overlays)
> (put 'yas--active-field-overlay 'permanent-local t)
> (put 'yas--field-protection-overlays 'permanent-local t)
2287c2881
< (defstruct (yas/snippet (:constructor yas/make-snippet ()))
---
> (defstruct (yas--snippet (:constructor yas--make-snippet ()))
2293c2887
<   (id (yas/snippet-next-id) :read-only t)
---
>   (id (yas--snippet-next-id) :read-only t)
2301c2895
< (defstruct (yas/field (:constructor yas/make-field (number start end parent-field)))
---
> (defstruct (yas--field (:constructor yas--make-field (number start end parent-field)))
2311c2905
< (defstruct (yas/mirror (:constructor yas/make-mirror (start end transform)))
---
> (defstruct (yas--mirror (:constructor yas--make-mirror (start end transform)))
2314a2909
>   parent-field
2317c2912
< (defstruct (yas/exit (:constructor yas/make-exit (marker)))
---
> (defstruct (yas--exit (:constructor yas--make-exit (marker)))
2321,2333c2916,2932
< (defun yas/apply-transform (field-or-mirror field)
<   "Calculate the value of the field/mirror. If there's a transform
< for this field, apply it. Otherwise, returned nil."
<   (let* ((yas/text (yas/field-text-for-display field))
<          (text yas/text)
<          (yas/modified-p (yas/field-modified-p field))
<          (yas/moving-away-p nil)
<          (transform (if (yas/mirror-p field-or-mirror)
<                         (yas/mirror-transform field-or-mirror)
<                       (yas/field-transform field-or-mirror)))
<          (start-point (if (yas/mirror-p field-or-mirror)
<                           (yas/mirror-start field-or-mirror)
<                         (yas/field-start field-or-mirror)))
---
> (defun yas--apply-transform (field-or-mirror field &optional empty-on-nil-p)
>   "Calculate transformed string for FIELD-OR-MIRROR from FIELD.
> 
> If there is no transform for ht field, return nil.
> 
> If there is a transform but it returns nil, return the empty
> string iff EMPTY-ON-NIL-P is true."
>   (let* ((yas-text (yas--field-text-for-display field))
>          (text yas-text)
>          (yas-modified-p (yas--field-modified-p field))
>          (yas-moving-away-p nil)
>          (transform (if (yas--mirror-p field-or-mirror)
>                         (yas--mirror-transform field-or-mirror)
>                       (yas--field-transform field-or-mirror)))
>          (start-point (if (yas--mirror-p field-or-mirror)
>                           (yas--mirror-start field-or-mirror)
>                         (yas--field-start field-or-mirror)))
2337c2936,2937
<                              (yas/read-and-eval-string transform)))))
---
>                              (let ((ret (yas--eval-lisp transform)))
>                                (or ret (and empty-on-nil-p "")))))))
2340c2940
< (defsubst yas/replace-all (from to &optional text)
---
> (defsubst yas--replace-all (from to &optional text)
2350c2950
< (defun yas/snippet-find-field (snippet number)
---
> (defun yas--snippet-find-field (snippet number)
2352,2353c2952,2953
<                (eq number (yas/field-number field)))
<            (yas/snippet-fields snippet)))
---
>                (eq number (yas--field-number field)))
>            (yas--snippet-fields snippet)))
2355c2955
< (defun yas/snippet-sort-fields (snippet)
---
> (defun yas--snippet-sort-fields (snippet)
2357,2360c2957,2959
<   (setf (yas/snippet-fields snippet)
<         (sort (yas/snippet-fields snippet)
<               '(lambda (field1 field2)
<                  (yas/snippet-field-compare field1 field2)))))
---
>   (setf (yas--snippet-fields snippet)
>         (sort (yas--snippet-fields snippet)
>               #'yas--snippet-field-compare)))
2362c2961
< (defun yas/snippet-field-compare (field1 field2)
---
> (defun yas--snippet-field-compare (field1 field2)
2366,2367c2965,2966
<   (let ((n1 (yas/field-number field1))
<         (n2 (yas/field-number field2)))
---
>   (let ((n1 (yas--field-number field1))
>         (n2 (yas--field-number field2)))
2370,2371c2969,2971
<             (< n1 n2)
<           t)
---
>             (or (zerop n2) (and (not (zerop n1))
>                                 (< n1 n2)))
>           (not (zerop n1)))
2373,2375c2973,2975
<           nil
<         (< (yas/field-start field1)
<            (yas/field-start field2))))))
---
>           (zerop n2)
>         (< (yas--field-start field1)
>            (yas--field-start field2))))))
2377c2977
< (defun yas/field-probably-deleted-p (snippet field)
---
> (defun yas--field-probably-deleted-p (snippet field)
2379,2382c2979,2996
<   (and (zerop (- (yas/field-start field) (yas/field-end field)))
<        (or (yas/field-parent-field field)
<            (and (eq field (car (last (yas/snippet-fields snippet))))
<                 (= (yas/field-start field) (overlay-end (yas/snippet-control-overlay snippet)))))))
---
>   (and
>    ;; field must be zero lentgh
>    ;;
>    (zerop (- (yas--field-start field) (yas--field-end field)))
>    ;; skip if:
>    (or
>     ;;  1) is a nested field and it's been modified
>     ;;
>     (and (yas--field-parent-field field)
>          (yas--field-modified-p field))
>     ;;  2) ends just before the snippet end
>     ;;
>     (and (eq field (car (last (yas--snippet-fields snippet))))
>          (= (yas--field-start field) (overlay-end (yas--snippet-control-overlay snippet)))))
>    ;; the field numbered 0, just before the exit marker, should
>    ;; never be skipped
>    ;;
>    (not (zerop (yas--field-number field)))))
2384c2998
< (defun yas/snippets-at-point (&optional all-snippets)
---
> (defun yas--snippets-at-point (&optional all-snippets)
2389c3003
<                                               (overlay-get ov 'yas/snippet))
---
>                                               (overlay-get ov 'yas--snippet))
2392c3006
<                                             (overlays-at (point))))))
---
>                                             (nconc (overlays-at (point)) (overlays-at (1- (point))))))))
2394c3008
<        (<= (yas/snippet-id s2) (yas/snippet-id s1)))))
---
>        (<= (yas--snippet-id s2) (yas--snippet-id s1)))))
2396c3010
< (defun yas/next-field-or-maybe-expand ()
---
> (defun yas-next-field-or-maybe-expand ()
2398c3012
< delegate to `yas/next-field'."
---
> delegate to `yas-next-field'."
2400,2402c3014,3016
<   (if yas/triggers-in-field
<       (let ((yas/fallback-behavior 'return-nil)
<             (active-field (overlay-get yas/active-field-overlay 'yas/field)))
---
>   (if yas-triggers-in-field
>       (let ((yas-fallback-behavior 'return-nil)
>             (active-field (overlay-get yas--active-field-overlay 'yas--field)))
2404,2406c3018,3020
<           (unless (yas/expand-1 active-field)
<             (yas/next-field))))
<     (yas/next-field)))
---
>           (unless (yas-expand-from-trigger-key active-field)
>             (yas-next-field))))
>     (yas-next-field)))
2408c3022
< (defun yas/next-field (&optional arg)
---
> (defun yas-next-field (&optional arg)
2413,2414c3027,3028
<          (snippet (first (yas/snippets-at-point)))
<          (active-field (overlay-get yas/active-field-overlay 'yas/field))
---
>          (snippet (first (yas--snippets-at-point)))
>          (active-field (overlay-get yas--active-field-overlay 'yas--field))
2417,2418c3031,3032
<                                           (yas/field-probably-deleted-p snippet field)))
<                                  (yas/snippet-fields snippet)))
---
>                                           (yas--field-probably-deleted-p snippet field)))
>                                  (yas--snippet-fields snippet)))
2421c3035
<          (target-field (nth target-pos live-fields)))
---
>          (target-field (and target-pos (nth target-pos live-fields))))
2425,2429c3039,3043
<                (yas/field-transform active-field))
<       (let* ((yas/moving-away-p t)
<              (yas/text (yas/field-text-for-display active-field))
<              (text yas/text)
<              (yas/modified-p (yas/field-modified-p active-field)))
---
>                (yas--field-transform active-field))
>       (let* ((yas-moving-away-p t)
>              (yas-text (yas--field-text-for-display active-field))
>              (text yas-text)
>              (yas-modified-p (yas--field-modified-p active-field)))
2431c3045
<         (yas/read-and-eval-string (yas/field-transform active-field))))
---
>         (yas--eval-lisp (yas--field-transform active-field))))
2433,2434c3047,3048
<     (cond ((>= target-pos (length live-fields))
<            (yas/exit-snippet snippet))
---
>     (cond ((and target-pos (>= target-pos (length live-fields)))
>            (yas-exit-snippet snippet))
2436c3050
<            (yas/move-to-field snippet target-field))
---
>            (yas--move-to-field snippet target-field))
2440c3054
< (defun yas/place-overlays (snippet field)
---
> (defun yas--place-overlays (snippet field)
2442,2443c3056,3057
<   (yas/make-move-field-protection-overlays snippet field)
<   (yas/make-move-active-field-overlay snippet field))
---
>   (yas--make-move-field-protection-overlays snippet field)
>   (yas--make-move-active-field-overlay snippet field))
2445c3059
< (defun yas/move-to-field (snippet field)
---
> (defun yas--move-to-field (snippet field)
2449,2458c3063,3080
<   (goto-char (yas/field-start field))
<   (setf (yas/snippet-active-field snippet) field)
<   (yas/place-overlays snippet field)
<   (overlay-put yas/active-field-overlay 'yas/field field)
<   ;; primary field transform: first call to snippet transform
<   (unless (yas/field-modified-p field)
<     (if (yas/field-update-display field snippet)
<         (let ((inhibit-modification-hooks t))
<           (yas/update-mirrors snippet))
<       (setf (yas/field-modified-p field) nil))))
---
>   (goto-char (yas--field-start field))
>   (yas--place-overlays snippet field)
>   (overlay-put yas--active-field-overlay 'yas--field field)
>   (let ((number (yas--field-number field)))
>     ;; check for the special ${0: ...} field
>     (if (and number (zerop number))
>         (progn
>           (set-mark (yas--field-end field))
>           (setf (yas--snippet-force-exit snippet)
>                 (or (yas--field-transform field)
>                     t)))
>       ;; make this field active
>       (setf (yas--snippet-active-field snippet) field)
>       ;; primary field transform: first call to snippet transform
>       (unless (yas--field-modified-p field)
>         (if (yas--field-update-display field snippet)
>             (yas--update-mirrors snippet)
>           (setf (yas--field-modified-p field) nil))))))
2460c3082
< (defun yas/prev-field ()
---
> (defun yas-prev-field ()
2463c3085
<   (yas/next-field -1))
---
>   (yas-next-field -1))
2465c3087
< (defun yas/abort-snippet (&optional snippet)
---
> (defun yas-abort-snippet (&optional snippet)
2468c3090
<                      (car (yas/snippets-at-point)))))
---
>                      (car (yas--snippets-at-point)))))
2470c3092
<       (setf (yas/snippet-force-exit snippet) t))))
---
>       (setf (yas--snippet-force-exit snippet) t))))
2472c3094
< (defun yas/exit-snippet (snippet)
---
> (defun yas-exit-snippet (snippet)
2474,2478c3096,3101
<   (interactive)
<   (setf (yas/snippet-force-exit snippet) t)
<   (goto-char (if (yas/snippet-exit snippet)
<                  (yas/exit-marker (yas/snippet-exit snippet))
<                (overlay-end (yas/snippet-control-overlay snippet)))))
---
>   (interactive (list (first (yas--snippets-at-point))))
>   (when snippet
>     (setf (yas--snippet-force-exit snippet) t)
>     (goto-char (if (yas--snippet-exit snippet)
>                    (yas--exit-marker (yas--snippet-exit snippet))
>                  (overlay-end (yas--snippet-control-overlay snippet))))))
2480c3103
< (defun yas/exit-all-snippets ()
---
> (defun yas-exit-all-snippets ()
2484,2486c3107,3109
<             (yas/exit-snippet snippet)
<             (yas/check-commit-snippet))
<         (yas/snippets-at-point)))
---
>             (yas-exit-snippet snippet)
>             (yas--check-commit-snippet))
>         (yas--snippets-at-point 'all-snippets)))
2489,2500c3112
< ;;; Apropos markers-to-points:
< ;;;
< ;;; This was found useful for performance reasons, so that an
< ;;; excessive number of live markers aren't kept around in the
< ;;; `buffer-undo-list'. However, in `markers-to-points', the
< ;;; set-to-nil markers can't simply be discarded and replaced with
< ;;; fresh ones in `points-to-markers'. The original marker that was
< ;;; just set to nil has to be reused.
< ;;;
< ;;; This shouldn't bring horrible problems with undo/redo, but it
< ;;; you never know
< ;;;
---
> ;;; Some low level snippet-routines:
2502,2524c3114,3118
< (defun yas/markers-to-points (snippet)
<   "Convert all markers in SNIPPET to a cons (POINT . MARKER)
< where POINT is the original position of the marker and MARKER is
< the original marker object with the position set to nil."
<   (dolist (field (yas/snippet-fields snippet))
<     (let ((start (marker-position (yas/field-start field)))
<           (end (marker-position (yas/field-end field))))
<       (set-marker (yas/field-start field) nil)
<       (set-marker (yas/field-end field) nil)
<       (setf (yas/field-start field) (cons start (yas/field-start field)))
<       (setf (yas/field-end field) (cons end (yas/field-end field))))
<     (dolist (mirror (yas/field-mirrors field))
<       (let ((start (marker-position (yas/mirror-start mirror)))
<             (end (marker-position (yas/mirror-end mirror))))
<         (set-marker (yas/mirror-start mirror) nil)
<         (set-marker (yas/mirror-end mirror) nil)
<         (setf (yas/mirror-start mirror) (cons start (yas/mirror-start mirror)))
<         (setf (yas/mirror-end mirror) (cons end (yas/mirror-end mirror))))))
<   (let ((snippet-exit (yas/snippet-exit snippet)))
<     (when snippet-exit
<       (let ((exit (marker-position (yas/exit-marker snippet-exit))))
<         (set-marker (yas/exit-marker snippet-exit) nil)
<         (setf (yas/exit-marker snippet-exit) (cons exit (yas/exit-marker snippet-exit)))))))
---
> (defmacro yas--inhibit-overlay-hooks (&rest body)
>   "Run BODY with `yas--inhibit-overlay-hooks' set to t."
>   (declare (indent 0))
>   `(let ((yas--inhibit-overlay-hooks t))
>      (progn ,@body)))
2526,2542c3120,3121
< (defun yas/points-to-markers (snippet)
<   "Convert all cons (POINT . MARKER) in SNIPPET to markers. This
< is done by setting MARKER to POINT with `set-marker'."
<   (dolist (field (yas/snippet-fields snippet))
<     (setf (yas/field-start field) (set-marker (cdr (yas/field-start field))
<                                               (car (yas/field-start field))))
<     (setf (yas/field-end field) (set-marker (cdr (yas/field-end field))
<                                             (car (yas/field-end field))))
<     (dolist (mirror (yas/field-mirrors field))
<       (setf (yas/mirror-start mirror) (set-marker (cdr (yas/mirror-start mirror))
<                                                   (car (yas/mirror-start mirror))))
<       (setf (yas/mirror-end mirror) (set-marker (cdr (yas/mirror-end mirror))
<                                                 (car (yas/mirror-end mirror))))))
<   (let ((snippet-exit (yas/snippet-exit snippet)))
<     (when snippet-exit
<       (setf (yas/exit-marker snippet-exit) (set-marker (cdr (yas/exit-marker snippet-exit))
<                                                        (car (yas/exit-marker snippet-exit)))))))
---
> (defvar yas-snippet-beg nil "Beginning position of the last snippet commited.")
> (defvar yas-snippet-end nil "End position of the last snippet commited.")
2544c3123
< (defun yas/commit-snippet (snippet &optional no-hooks)
---
> (defun yas--commit-snippet (snippet)
2546,2549c3125
< snippet as ordinary text.
< 
< Return a buffer position where the point should be placed if
< exiting the snippet.
---
> snippet as ordinary text."
2551,2555c3127
< NO-HOOKS means don't run the `yas/after-exit-snippet-hook' hooks."
< 
<   (let ((control-overlay (yas/snippet-control-overlay snippet))
<         yas/snippet-beg
<         yas/snippet-end)
---
>   (let ((control-overlay (yas--snippet-control-overlay snippet)))
2562,2563c3134,3135
<       (setq yas/snippet-beg (overlay-start control-overlay))
<       (setq yas/snippet-end (overlay-end control-overlay))
---
>       (setq yas-snippet-beg (overlay-start control-overlay))
>       (setq yas-snippet-end (overlay-end control-overlay))
2566,2570c3138,3142
<     (let ((inhibit-modification-hooks t))
<       (when yas/active-field-overlay
<         (delete-overlay yas/active-field-overlay))
<       (when yas/field-protection-overlays
<         (mapc #'delete-overlay yas/field-protection-overlays)))
---
>     (yas--inhibit-overlay-hooks
>       (when yas--active-field-overlay
>         (delete-overlay yas--active-field-overlay))
>       (when yas--field-protection-overlays
>         (mapc #'delete-overlay yas--field-protection-overlays)))
2574c3146
<     ;; `yas/snippet-end'...
---
>     ;; `yas-snippet-end'...
2576,2578c3148,3150
<     (let ((previous-field (yas/snippet-previous-active-field snippet)))
<       (when (and yas/snippet-end previous-field)
<         (yas/advance-end-maybe previous-field yas/snippet-end)))
---
>     (let ((previous-field (yas--snippet-previous-active-field snippet)))
>       (when (and yas-snippet-end previous-field)
>         (yas--advance-end-maybe previous-field yas-snippet-end)))
2582c3154
<     (yas/markers-to-points snippet)
---
>     (yas--markers-to-points snippet)
2586,2587c3158,3159
<     (if yas/snippet-revival
<         (push `(apply yas/snippet-revive ,yas/snippet-beg ,yas/snippet-end ,snippet)
---
>     (if yas-snippet-revival
>         (push `(apply yas--snippet-revive ,yas-snippet-beg ,yas-snippet-end ,snippet)
2590,2591c3162,3163
<       ;; again from `yas/take-care-of-redo'....
<       (setf (yas/snippet-fields snippet) nil))
---
>       ;; again from `yas--take-care-of-redo'....
>       (setf (yas--snippet-fields snippet) nil)))
2593,2599c3165
<     ;; XXX: `yas/after-exit-snippet-hook' should be run with
<     ;; `yas/snippet-beg' and `yas/snippet-end' bound. That might not
<     ;; be the case if the main overlay had somehow already
<     ;; disappeared, which sometimes happens when the snippet's messed
<     ;; up...
<     ;;
<     (unless no-hooks (run-hooks 'yas/after-exit-snippet-hook)))
---
>   (yas--message 3 "Snippet %s exited." (yas--snippet-id snippet)))
2601c3167,3171
<   (message "[yas] snippet exited."))
---
> (defun yas--safely-run-hooks (hook-var)
>   (condition-case error
>       (run-hooks hook-var)
>     (error
>      (yas--message 3 "%s error: %s" hook-var (error-message-string error)))))
2603c3173,3174
< (defun yas/check-commit-snippet ()
---
> 
> (defun yas--check-commit-snippet ()
2606,2607c3177,3179
<   (let* ((snippets (yas/snippets-at-point 'all-snippets))
<          (snippets-left snippets))
---
>   (let* ((snippets (yas--snippets-at-point 'all-snippets))
>          (snippets-left snippets)
>          (snippet-exit-transform))
2609,2612c3181,3184
<       (let ((active-field (yas/snippet-active-field snippet)))
<         (cond ((or (prog1 (yas/snippet-force-exit snippet)
<                      (setf (yas/snippet-force-exit snippet) nil))
<                    (not (and active-field (yas/field-contains-point-p active-field))))
---
>       (let ((active-field (yas--snippet-active-field snippet)))
>         (setq snippet-exit-transform (yas--snippet-force-exit snippet))
>         (cond ((or snippet-exit-transform
>                    (not (and active-field (yas--field-contains-point-p active-field))))
2614c3186,3187
<                (yas/commit-snippet snippet snippets-left))
---
>                (setf (yas--snippet-force-exit snippet) nil)
>                (yas--commit-snippet snippet))
2616,2617c3189,3190
<                     (or (not yas/active-field-overlay)
<                         (not (overlay-buffer yas/active-field-overlay))))
---
>                     (or (not yas--active-field-overlay)
>                         (not (overlay-buffer yas--active-field-overlay))))
2624,2625c3197,3198
<                  (yas/move-to-field snippet active-field)
<                  (yas/update-mirrors snippet)))
---
>                  (yas--move-to-field snippet active-field)
>                  (yas--update-mirrors snippet)))
2628,2630c3201,3258
<     (unless snippets-left
<       (remove-hook 'post-command-hook 'yas/post-command-handler 'local)
<       (remove-hook 'pre-command-hook 'yas/pre-command-handler 'local))))
---
>     (unless (or (null snippets) snippets-left)
>       (if snippet-exit-transform
>           (yas--eval-lisp-no-saves snippet-exit-transform))
>       (yas--safely-run-hooks 'yas-after-exit-snippet-hook))))
> 
> ;; Apropos markers-to-points:
> ;;
> ;; This was found useful for performance reasons, so that an
> ;; excessive number of live markers aren't kept around in the
> ;; `buffer-undo-list'. However, in `markers-to-points', the
> ;; set-to-nil markers can't simply be discarded and replaced with
> ;; fresh ones in `points-to-markers'. The original marker that was
> ;; just set to nil has to be reused.
> ;;
> ;; This shouldn't bring horrible problems with undo/redo, but it
> ;; you never know
> ;;
> (defun yas--markers-to-points (snippet)
>   "Convert all markers in SNIPPET to a cons (POINT . MARKER)
> where POINT is the original position of the marker and MARKER is
> the original marker object with the position set to nil."
>   (dolist (field (yas--snippet-fields snippet))
>     (let ((start (marker-position (yas--field-start field)))
>           (end (marker-position (yas--field-end field))))
>       (set-marker (yas--field-start field) nil)
>       (set-marker (yas--field-end field) nil)
>       (setf (yas--field-start field) (cons start (yas--field-start field)))
>       (setf (yas--field-end field) (cons end (yas--field-end field))))
>     (dolist (mirror (yas--field-mirrors field))
>       (let ((start (marker-position (yas--mirror-start mirror)))
>             (end (marker-position (yas--mirror-end mirror))))
>         (set-marker (yas--mirror-start mirror) nil)
>         (set-marker (yas--mirror-end mirror) nil)
>         (setf (yas--mirror-start mirror) (cons start (yas--mirror-start mirror)))
>         (setf (yas--mirror-end mirror) (cons end (yas--mirror-end mirror))))))
>   (let ((snippet-exit (yas--snippet-exit snippet)))
>     (when snippet-exit
>       (let ((exit (marker-position (yas--exit-marker snippet-exit))))
>         (set-marker (yas--exit-marker snippet-exit) nil)
>         (setf (yas--exit-marker snippet-exit) (cons exit (yas--exit-marker snippet-exit)))))))
> 
> (defun yas--points-to-markers (snippet)
>   "Convert all cons (POINT . MARKER) in SNIPPET to markers. This
> is done by setting MARKER to POINT with `set-marker'."
>   (dolist (field (yas--snippet-fields snippet))
>     (setf (yas--field-start field) (set-marker (cdr (yas--field-start field))
>                                               (car (yas--field-start field))))
>     (setf (yas--field-end field) (set-marker (cdr (yas--field-end field))
>                                             (car (yas--field-end field))))
>     (dolist (mirror (yas--field-mirrors field))
>       (setf (yas--mirror-start mirror) (set-marker (cdr (yas--mirror-start mirror))
>                                                   (car (yas--mirror-start mirror))))
>       (setf (yas--mirror-end mirror) (set-marker (cdr (yas--mirror-end mirror))
>                                                 (car (yas--mirror-end mirror))))))
>   (let ((snippet-exit (yas--snippet-exit snippet)))
>     (when snippet-exit
>       (setf (yas--exit-marker snippet-exit) (set-marker (cdr (yas--exit-marker snippet-exit))
>                                                        (car (yas--exit-marker snippet-exit)))))))
2632c3260
< (defun yas/field-contains-point-p (field &optional point)
---
> (defun yas--field-contains-point-p (field &optional point)
2635,2636c3263,3264
<     (and (>= point (yas/field-start field))
<          (<= point (yas/field-end field)))))
---
>     (and (>= point (yas--field-start field))
>          (<= point (yas--field-end field)))))
2638c3266
< (defun yas/field-text-for-display (field)
---
> (defun yas--field-text-for-display (field)
2640c3268
<   (buffer-substring (yas/field-start field) (yas/field-end field)))
---
>   (buffer-substring (yas--field-start field) (yas--field-end field)))
2642c3270
< (defun yas/undo-in-progress ()
---
> (defun yas--undo-in-progress ()
2648c3276
< (defun yas/make-control-overlay (snippet start end)
---
> (defun yas--make-control-overlay (snippet start end)
2656,2657c3284,3286
<     (overlay-put overlay 'keymap yas/keymap)
<     (overlay-put overlay 'yas/snippet snippet)
---
>     (overlay-put overlay 'keymap yas-keymap)
>     (overlay-put overlay 'priority 100)
>     (overlay-put overlay 'yas--snippet snippet)
2660c3289
< (defun yas/skip-and-clear-or-delete-char (&optional field)
---
> (defun yas-skip-and-clear-or-delete-char (&optional field)
2666,2668c3295,3297
<                    (and yas/active-field-overlay
<                         (overlay-buffer yas/active-field-overlay)
<                         (overlay-get yas/active-field-overlay 'yas/field)))))
---
>                    (and yas--active-field-overlay
>                         (overlay-buffer yas--active-field-overlay)
>                         (overlay-get yas--active-field-overlay 'yas--field)))))
2670,2673c3299,3302
<                 (not (yas/field-modified-p field))
<                 (eq (point) (marker-position (yas/field-start field))))
<            (yas/skip-and-clear field)
<            (yas/next-field 1))
---
>                 (not (yas--field-modified-p field))
>                 (eq (point) (marker-position (yas--field-start field))))
>            (yas--skip-and-clear field)
>            (yas-next-field 1))
2677c3306
< (defun yas/skip-and-clear (field)
---
> (defun yas--skip-and-clear (field)
2679,2680c3308,3324
<   (setf (yas/field-modified-p field) t)
<   (delete-region (yas/field-start field) (yas/field-end field)))
---
>   ;; Just before skipping-and-clearing the field, mark its children
>   ;; fields as modified, too. If the childen have mirrors-in-fields
>   ;; this prevents them from updating erroneously (we're skipping and
>   ;; deleting!).
>   ;;
>   (yas--mark-this-and-children-modified field)
>   (delete-region (yas--field-start field) (yas--field-end field)))
> 
> (defun yas--mark-this-and-children-modified (field)
>   (setf (yas--field-modified-p field) t)
>   (let ((fom (yas--field-next field)))
>     (while (and fom
>                 (yas--fom-parent-field fom))
>       (when (and (eq (yas--fom-parent-field fom) field)
>                  (yas--field-p fom))
>         (yas--mark-this-and-children-modified fom))
>       (setq fom (yas--fom-next fom)))))
2682c3326
< (defun yas/make-move-active-field-overlay (snippet field)
---
> (defun yas--make-move-active-field-overlay (snippet field)
2686,2693c3330,3337
<   (if (and yas/active-field-overlay
<            (overlay-buffer yas/active-field-overlay))
<       (move-overlay yas/active-field-overlay
<                     (yas/field-start field)
<                     (yas/field-end field))
<     (setq yas/active-field-overlay
<           (make-overlay (yas/field-start field)
<                         (yas/field-end field)
---
>   (if (and yas--active-field-overlay
>            (overlay-buffer yas--active-field-overlay))
>       (move-overlay yas--active-field-overlay
>                     (yas--field-start field)
>                     (yas--field-end field))
>     (setq yas--active-field-overlay
>           (make-overlay (yas--field-start field)
>                         (yas--field-end field)
2695,2702c3339,3346
<     (overlay-put yas/active-field-overlay 'priority 100)
<     (overlay-put yas/active-field-overlay 'face 'yas/field-highlight-face)
<     (overlay-put yas/active-field-overlay 'yas/snippet snippet)
<     (overlay-put yas/active-field-overlay 'modification-hooks '(yas/on-field-overlay-modification))
<     (overlay-put yas/active-field-overlay 'insert-in-front-hooks
<                  '(yas/on-field-overlay-modification))
<     (overlay-put yas/active-field-overlay 'insert-behind-hooks
<                  '(yas/on-field-overlay-modification))))
---
>     (overlay-put yas--active-field-overlay 'priority 100)
>     (overlay-put yas--active-field-overlay 'face 'yas-field-highlight-face)
>     (overlay-put yas--active-field-overlay 'yas--snippet snippet)
>     (overlay-put yas--active-field-overlay 'modification-hooks '(yas--on-field-overlay-modification))
>     (overlay-put yas--active-field-overlay 'insert-in-front-hooks
>                  '(yas--on-field-overlay-modification))
>     (overlay-put yas--active-field-overlay 'insert-behind-hooks
>                  '(yas--on-field-overlay-modification))))
2704c3348,3351
< (defun yas/on-field-overlay-modification (overlay after? beg end &optional length)
---
> (defvar yas--inhibit-overlay-hooks nil
>   "Bind this temporarity to non-nil to prevent running `yas--on-*-modification'.")
> 
> (defun yas--on-field-overlay-modification (overlay after? beg end &optional length)
2710,2711c3357,3361
<   (unless (yas/undo-in-progress)
<     (let ((field (overlay-get yas/active-field-overlay 'yas/field)))
---
>   (unless (or yas--inhibit-overlay-hooks
>               (yas--undo-in-progress))
>     (let* ((field (overlay-get overlay 'yas--field))
>            (number (and field (yas--field-number field)))
>            (snippet (overlay-get yas--active-field-overlay 'yas--snippet)))
2713,2718c3363,3366
<              (yas/advance-end-maybe field (overlay-end overlay))
< ;;; primary field transform: normal calls to expression
<              (let ((saved-point (point)))
<                (yas/field-update-display field (car (yas/snippets-at-point)))
<                (goto-char saved-point))
<              (yas/update-mirrors (car (yas/snippets-at-point))))
---
>              (yas--advance-end-maybe field (overlay-end overlay))
>              (save-excursion
>                (yas--field-update-display field snippet))
>              (yas--update-mirrors snippet))
2721,2726c3369,3374
<                         (not (yas/field-modified-p field))
<                         (eq (point) (if (markerp (yas/field-start field))
<                                         (marker-position (yas/field-start field))
<                                       (yas/field-start field))))
<                (yas/skip-and-clear field))
<              (setf (yas/field-modified-p field) t))))))
---
>                         (not (yas--field-modified-p field))
>                         (eq (point) (if (markerp (yas--field-start field))
>                                         (marker-position (yas--field-start field))
>                                       (yas--field-start field))))
>                (yas--skip-and-clear field))
>              (setf (yas--field-modified-p field) t))))))
2729,2746c3377,3393
< ;;;
< ;;; These exist for nasty users who will try to delete parts of the
< ;;; snippet outside the active field. Actual protection happens in
< ;;; `yas/on-protection-overlay-modification'.
< ;;;
< ;;; Currently this signals an error which inhibits the command. For
< ;;; commands that move point (like `kill-line'), point is restored in
< ;;; the `yas/post-command-handler' using a global
< ;;; `yas/protection-violation' variable.
< ;;;
< ;;; Alternatively, I've experimented with an implementation that
< ;;; commits the snippet before actually calling `this-command'
< ;;; interactively, and then signals an eror, which is ignored. but
< ;;; blocks all other million modification hooks. This presented some
< ;;; problems with stacked expansion.
< ;;;
< 
< (defun yas/make-move-field-protection-overlays (snippet field)
---
> ;;
> ;; These exist for nasty users who will try to delete parts of the
> ;; snippet outside the active field. Actual protection happens in
> ;; `yas--on-protection-overlay-modification'.
> ;;
> ;; Currently this signals an error which inhibits the command. For
> ;; commands that move point (like `kill-line'), point is restored in
> ;; the `yas--post-command-handler' using a global
> ;; `yas--protection-violation' variable.
> ;;
> ;; Alternatively, I've experimented with an implementation that
> ;; commits the snippet before actually calling `this-command'
> ;; interactively, and then signals an eror, which is ignored. but
> ;; blocks all other million modification hooks. This presented some
> ;; problems with stacked expansion.
> ;;
> (defun yas--make-move-field-protection-overlays (snippet field)
2750,2751c3397,3398
<   (let ((start (yas/field-start field))
<         (end (yas/field-end field)))
---
>   (let ((start (yas--field-start field))
>         (end (yas--field-end field)))
2759c3406
<         (let ((inhibit-modification-hooks t))
---
>         (yas--inhibit-overlay-hooks
2764,2767c3411,3414
<     (cond ((and yas/field-protection-overlays
<                 (every #'overlay-buffer yas/field-protection-overlays))
<            (move-overlay (first yas/field-protection-overlays) (1- start) start)
<            (move-overlay (second yas/field-protection-overlays) end (1+ end)))
---
>     (cond ((and yas--field-protection-overlays
>                 (every #'overlay-buffer yas--field-protection-overlays))
>            (move-overlay (first yas--field-protection-overlays) (1- start) start)
>            (move-overlay (second yas--field-protection-overlays) end (1+ end)))
2769c3416
<            (setq yas/field-protection-overlays
---
>            (setq yas--field-protection-overlays
2772,2774c3419,3421
<            (dolist (ov yas/field-protection-overlays)
<              (overlay-put ov 'face 'yas/field-debug-face)
<              (overlay-put ov 'yas/snippet snippet)
---
>            (dolist (ov yas--field-protection-overlays)
>              (overlay-put ov 'face 'yas--field-debug-face)
>              (overlay-put ov 'yas--snippet snippet)
2776c3423
<              (overlay-put ov 'modification-hooks '(yas/on-protection-overlay-modification)))))))
---
>              (overlay-put ov 'modification-hooks '(yas--on-protection-overlay-modification)))))))
2778c3425
< (defvar yas/protection-violation nil
---
> (defvar yas--protection-violation nil
2782c3429
< `yas/post-command-handler' can check it and reset its value to
---
> `yas--post-command-handler' can check it and reset its value to
2786c3433
< (defun yas/on-protection-overlay-modification (overlay after? beg end &optional length)
---
> (defun yas--on-protection-overlay-modification (overlay after? beg end &optional length)
2790,2793c3437,3441
<   (cond ((not (or after?
<                   (yas/undo-in-progress)))
<          (setq yas/protection-violation (point))
<          (error "Exit the snippet first!"))))
---
>   (unless yas--inhibit-overlay-hooks
>     (cond ((not (or after?
>                     (yas--undo-in-progress)))
>            (setq yas--protection-violation (point))
>            (error "Exit the snippet first!")))))
2798,2819c3446,3472
< ;;; Apropos stacked expansion:
< ;;;
< ;;; the parent snippet does not run its fields modification hooks
< ;;; (`yas/on-field-overlay-modification' and
< ;;; `yas/on-protection-overlay-modification') while the child snippet
< ;;; is active. This means, among other things, that the mirrors of the
< ;;; parent snippet are not updated, this only happening when one exits
< ;;; the child snippet.
< ;;;
< ;;; Unfortunately, this also puts some ugly (and not fully-tested)
< ;;; bits of code in `yas/expand-snippet' and
< ;;; `yas/commit-snippet'. I've tried to mark them with "stacked
< ;;; expansion:".
< ;;;
< ;;; This was thought to be safer in in an undo/redo perpective, but
< ;;; maybe the correct implementation is to make the globals
< ;;; `yas/active-field-overlay' and `yas/field-protection-overlays' be
< ;;; snippet-local and be active even while the child snippet is
< ;;; running. This would mean a lot of overlay modification hooks
< ;;; running, but if managed correctly (including overlay priorities)
< ;;; they should account for all situations...
< ;;;
---
> ;; Snippet expansion and "stacked" expansion:
> ;;
> ;; Stacked expansion is when you try to expand a snippet when already
> ;; inside a snippet expansion.
> ;;
> ;; The parent snippet does not run its fields modification hooks
> ;; (`yas--on-field-overlay-modification' and
> ;; `yas--on-protection-overlay-modification') while the child snippet
> ;; is active. This means, among other things, that the mirrors of the
> ;; parent snippet are not updated, this only happening when one exits
> ;; the child snippet.
> ;;
> ;; Unfortunately, this also puts some ugly (and not fully-tested)
> ;; bits of code in `yas-expand-snippet' and
> ;; `yas--commit-snippet'. I've tried to mark them with "stacked
> ;; expansion:".
> ;;
> ;; This was thought to be safer in in an undo/redo perpective, but
> ;; maybe the correct implementation is to make the globals
> ;; `yas--active-field-overlay' and `yas--field-protection-overlays' be
> ;; snippet-local and be active even while the child snippet is
> ;; running. This would mean a lot of overlay modification hooks
> ;; running, but if managed correctly (including overlay priorities)
> ;; they should account for all situations...
> ;;
> (defun yas-expand-snippet (content &optional start end expand-env)
>   "Expand snippet CONTENT at current point.
2821,2844c3474,3477
< (defun yas/expand-snippet (template &optional start end expand-env)
<   "Expand snippet at current point. Text between START and END
< will be deleted before inserting template."
<   (run-hooks 'yas/before-expand-snippet-hook)
< 
<   ;; If a region is active, set `yas/selected-text'
<   (setq yas/selected-text
<         (when mark-active
<           (prog1 (buffer-substring-no-properties (region-beginning)
<                                                  (region-end))
<             (unless start (setq start (region-beginning))
<                     (unless end (setq end (region-end)))))))
< 
<   (when start
<     (goto-char start))
< 
<   ;; stacked expansion: shoosh the overlay modification hooks
<   ;;
<   (let ((to-delete (and start end (buffer-substring-no-properties start end)))
<         (start (or start (point)))
<         (end (or end (point)))
<         (inhibit-modification-hooks t)
<         (column (current-column))
<         snippet)
---
> Text between START and END will be deleted before inserting
> template. EXPAND-ENV is are let-style variable to value bindings
> considered when expanding the snippet."
>   (run-hooks 'yas-before-expand-snippet-hook)
2845a3479,3497
>   ;;
>   (let* ((yas-selected-text (or yas-selected-text
>                                 (and (region-active-p)
>                                      (buffer-substring-no-properties (region-beginning)
>                                                                      (region-end)))))
>          (start (or start
>                     (and (region-active-p)
>                          (region-beginning))
>                     (point)))
>          (end (or end
>                   (and (region-active-p)
>                        (region-end))
>                   (point)))
>          (to-delete (and start
>                          end
>                          (buffer-substring-no-properties start end)))
>          snippet)
>     (goto-char start)
>     (setq yas--indent-original-column (current-column))
2850,2866c3502
<       (delete-region start end)
<       (setq yas/deleted-text to-delete))
< 
<     ;; Narrow the region down to the template, shoosh the
<     ;; `buffer-undo-list', and create the snippet, the new snippet
<     ;; updates its mirrors once, so we are left with some plain text.
<     ;; The undo action for deleting this plain text will get recorded
<     ;; at the end of this function.
<     (save-restriction
<       (narrow-to-region start start)
<       (let ((buffer-undo-list t))
<         ;; snippet creation might evaluate users elisp, which
<         ;; might generate errors, so we have to be ready to catch
<         ;; them mostly to make the undo information
<         ;;
<         (setq yas/start-column (save-restriction (widen) (current-column)))
<         (insert template)
---
>       (delete-region start end))
2868,2906c3504,3574
<         (setq snippet
<               (if expand-env
<                   (let ((read-vars (condition-case err
<                                        (read expand-env)
<                                      (error nil))))
<                     (eval `(let ,read-vars
<                              (yas/snippet-create (point-min) (point-max)))))
<                 (yas/snippet-create (point-min) (point-max))))))
< 
<     ;; stacked-expansion: This checks for stacked expansion, save the
<     ;; `yas/previous-active-field' and advance its boudary.
<     ;;
<     (let ((existing-field (and yas/active-field-overlay
<                                (overlay-buffer yas/active-field-overlay)
<                                (overlay-get yas/active-field-overlay 'yas/field))))
<       (when existing-field
<         (setf (yas/snippet-previous-active-field snippet) existing-field)
<         (yas/advance-end-maybe existing-field (overlay-end yas/active-field-overlay))))
< 
<     ;; Exit the snippet immediately if no fields
<     ;;
<     (unless (yas/snippet-fields snippet)
<       (yas/exit-snippet snippet))
< 
<     ;; Push two undo actions: the deletion of the inserted contents of
<     ;; the new snippet (without the "key") followed by an apply of
<     ;; `yas/take-care-of-redo' on the newly inserted snippet boundaries
<     ;;
<     (let ((start (overlay-start (yas/snippet-control-overlay snippet)))
<           (end (overlay-end (yas/snippet-control-overlay snippet))))
<       (push (cons start end) buffer-undo-list)
<       (push `(apply yas/take-care-of-redo ,start ,end ,snippet)
<             buffer-undo-list))
<     ;; Now, move to the first field
<     ;;
<     (let ((first-field (car (yas/snippet-fields snippet))))
<       (when first-field
<         (yas/move-to-field snippet first-field))))
<   (message "[yas] snippet expanded."))
---
>     (cond ((listp content)
>            ;; x) This is a snippet-command
>            ;;
>            (yas--eval-lisp-no-saves content))
>           (t
>            ;; x) This is a snippet-snippet :-)
>            ;;
>            ;;    Narrow the region down to the content, shoosh the
>            ;;    `buffer-undo-list', and create the snippet, the new
>            ;;    snippet updates its mirrors once, so we are left with
>            ;;    some plain text.  The undo action for deleting this
>            ;;    plain text will get recorded at the end.
>            ;;
>            ;;    stacked expansion: also shoosh the overlay modification hooks
>            (save-restriction
>              (narrow-to-region start start)
>              (let ((buffer-undo-list t))
>                ;; snippet creation might evaluate users elisp, which
>                ;; might generate errors, so we have to be ready to catch
>                ;; them mostly to make the undo information
>                ;;
>                (setq yas--start-column (save-restriction (widen) (current-column)))
>                (yas--inhibit-overlay-hooks
>                  (setq snippet
>                        (if expand-env
>                            (eval `(let* ,expand-env
>                                     (insert content)
>                                     (yas--snippet-create (point-min) (point-max))))
>                          (insert content)
>                          (yas--snippet-create (point-min) (point-max)))))))
> 
>            ;; stacked-expansion: This checks for stacked expansion, save the
>            ;; `yas--previous-active-field' and advance its boudary.
>            ;;
>            (let ((existing-field (and yas--active-field-overlay
>                                       (overlay-buffer yas--active-field-overlay)
>                                       (overlay-get yas--active-field-overlay 'yas--field))))
>              (when existing-field
>                (setf (yas--snippet-previous-active-field snippet) existing-field)
>                (yas--advance-end-maybe existing-field (overlay-end yas--active-field-overlay))))
> 
>            ;; Exit the snippet immediately if no fields
>            ;;
>            (unless (yas--snippet-fields snippet)
>              (yas-exit-snippet snippet))
> 
>            ;; Push two undo actions: the deletion of the inserted contents of
>            ;; the new snippet (without the "key") followed by an apply of
>            ;; `yas--take-care-of-redo' on the newly inserted snippet boundaries
>            ;;
>            ;; A small exception, if `yas-also-auto-indent-first-line'
>            ;; is t and `yas--indent' decides to indent the line to a
>            ;; point before the actual expansion point, undo would be
>            ;; messed up. We call the early point "newstart"".  case,
>            ;; and attempt to fix undo.
>            ;;
>            (let ((newstart (overlay-start (yas--snippet-control-overlay snippet)))
>                  (end (overlay-end (yas--snippet-control-overlay snippet))))
>              (when (< newstart start)
>                (push (cons (make-string (- start newstart) ? ) newstart) buffer-undo-list))
>              (push (cons newstart end) buffer-undo-list)
>              (push `(apply yas--take-care-of-redo ,start ,end ,snippet)
>                    buffer-undo-list))
>            ;; Now, schedule a move to the first field
>            ;;
>            (let ((first-field (car (yas--snippet-fields snippet))))
>              (when first-field
>                (sit-for 0) ;; fix issue 125
>                (yas--move-to-field snippet first-field)))
>            (yas--message 3 "snippet expanded.")
>            t))))
2908c3576
< (defun yas/take-care-of-redo (beg end snippet)
---
> (defun yas--take-care-of-redo (beg end snippet)
2915,2916c3583,3584
<   (when (yas/snippet-fields snippet)
<     (yas/commit-snippet snippet 'no-hooks)))
---
>   (when (yas--snippet-fields snippet)
>     (yas--commit-snippet snippet)))
2918c3586
< (defun yas/snippet-revive (beg end snippet)
---
> (defun yas--snippet-revive (beg end snippet)
2926c3594
< After revival, push the `yas/take-care-of-redo' in the
---
> After revival, push the `yas--take-care-of-redo' in the
2930c3598
<   (yas/points-to-markers snippet)
---
>   (yas--points-to-markers snippet)
2934,2935c3602,3603
<   (let ((target-field (or (yas/snippet-active-field snippet)
<                           (car (yas/snippet-fields snippet)))))
---
>   (let ((target-field (or (yas--snippet-active-field snippet)
>                           (car (yas--snippet-fields snippet)))))
2937,2940c3605,3606
<       (setf (yas/snippet-control-overlay snippet) (yas/make-control-overlay snippet beg end))
<       (overlay-put (yas/snippet-control-overlay snippet) 'yas/snippet snippet)
< 
<       (yas/move-to-field snippet target-field)
---
>       (setf (yas--snippet-control-overlay snippet) (yas--make-control-overlay snippet beg end))
>       (overlay-put (yas--snippet-control-overlay snippet) 'yas--snippet snippet)
2942,2943c3608
<       (add-hook 'post-command-hook 'yas/post-command-handler nil t)
<       (add-hook 'pre-command-hook 'yas/pre-command-handler t t)
---
>       (yas--move-to-field snippet target-field)
2945c3610
<       (push `(apply yas/take-care-of-redo ,beg ,end ,snippet)
---
>       (push `(apply yas--take-care-of-redo ,beg ,end ,snippet)
2948c3613
< (defun yas/snippet-create (begin end)
---
> (defun yas--snippet-create (begin end)
2952c3617
<   (let ((snippet (yas/make-snippet)))
---
>   (let ((snippet (yas--make-snippet)))
2954c3619
<     (yas/snippet-parse-create snippet)
---
>     (yas--snippet-parse-create snippet)
2957c3622
<     (yas/snippet-sort-fields snippet)
---
>     (yas--snippet-sort-fields snippet)
2960,2961c3625,3626
<     (setf (yas/snippet-control-overlay snippet)
<           (yas/make-control-overlay snippet (point-min) (point-max)))
---
>     (setf (yas--snippet-control-overlay snippet)
>           (yas--make-control-overlay snippet (point-min) (point-max)))
2966,2969d3630
<     ;; Setup hooks
<     (add-hook 'post-command-hook 'yas/post-command-handler nil t)
<     (add-hook 'pre-command-hook 'yas/pre-command-handler t t)
< 
2973,2988c3634,3658
< ;;; Apropos adjacencies: Once the $-constructs bits like "$n" and
< ;;; "${:n" are deleted in the recently expanded snippet, we might
< ;;; actually have many fields, mirrors (and the snippet exit) in the
< ;;; very same position in the buffer. Therefore we need to single-link
< ;;; the fields-or-mirrors-or-exit, which I have called "fom",
< ;;; according to their original positions in the buffer.
< ;;;
< ;;; Then we have operation `yas/advance-end-maybe' and
< ;;; `yas/advance-start-maybe', which conditionally push the starts and
< ;;; ends of these foms down the chain.
< ;;;
< ;;; This allows for like the printf with the magic ",":
< ;;;
< ;;;   printf ("${1:%s}\\n"${1:$(if (string-match "%" text) "," "\);")}  \
< ;;;   $2${1:$(if (string-match "%" text) "\);" "")}$0
< ;;;
---
> ;;; Apropos adjacencies and "fom's":
> ;;
> ;; Once the $-constructs bits like "$n" and "${:n" are deleted in the
> ;; recently expanded snippet, we might actually have many fields,
> ;; mirrors (and the snippet exit) in the very same position in the
> ;; buffer. Therefore we need to single-link the
> ;; fields-or-mirrors-or-exit (which I have abbreviated to "fom")
> ;; according to their original positions in the buffer.
> ;;
> ;; Then we have operation `yas--advance-end-maybe' and
> ;; `yas--advance-start-maybe', which conditionally push the starts and
> ;; ends of these foms down the chain.
> ;;
> ;; This allows for like the printf with the magic ",":
> ;;
> ;;   printf ("${1:%s}\\n"${1:$(if (string-match "%" text) "," "\);")}  \
> ;;   $2${1:$(if (string-match "%" text) "\);" "")}$0
> ;;
> (defun yas--fom-start (fom)
>   (cond ((yas--field-p fom)
>          (yas--field-start fom))
>         ((yas--mirror-p fom)
>          (yas--mirror-start fom))
>         (t
>          (yas--exit-marker fom))))
2990,2994c3660,3664
< (defun yas/fom-start (fom)
<   (cond ((yas/field-p fom)
<          (yas/field-start fom))
<         ((yas/mirror-p fom)
<          (yas/mirror-start fom))
---
> (defun yas--fom-end (fom)
>   (cond ((yas--field-p fom)
>          (yas--field-end fom))
>         ((yas--mirror-p fom)
>          (yas--mirror-end fom))
2996c3666
<          (yas/exit-marker fom))))
---
>          (yas--exit-marker fom))))
2998,3002c3668,3672
< (defun yas/fom-end (fom)
<   (cond ((yas/field-p fom)
<          (yas/field-end fom))
<         ((yas/mirror-p fom)
<          (yas/mirror-end fom))
---
> (defun yas--fom-next (fom)
>   (cond ((yas--field-p fom)
>          (yas--field-next fom))
>         ((yas--mirror-p fom)
>          (yas--mirror-next fom))
3004c3674
<          (yas/exit-marker fom))))
---
>          (yas--exit-next fom))))
3006,3010c3676,3680
< (defun yas/fom-next (fom)
<   (cond ((yas/field-p fom)
<          (yas/field-next fom))
<         ((yas/mirror-p fom)
<          (yas/mirror-next fom))
---
> (defun yas--fom-parent-field (fom)
>   (cond ((yas--field-p fom)
>          (yas--field-parent-field fom))
>         ((yas--mirror-p fom)
>          (yas--mirror-parent-field fom))
3012c3682
<          (yas/exit-next fom))))
---
>          nil)))
3014c3684
< (defun yas/calculate-adjacencies (snippet)
---
> (defun yas--calculate-adjacencies (snippet)
3019,3023c3689,3693
<   (flet ((yas/fom-set-next-fom (fom nextfom)
<                                (cond ((yas/field-p fom)
<                                       (setf (yas/field-next fom) nextfom))
<                                      ((yas/mirror-p fom)
<                                       (setf (yas/mirror-next fom) nextfom))
---
>   (flet ((yas--fom-set-next-fom (fom nextfom)
>                                (cond ((yas--field-p fom)
>                                       (setf (yas--field-next fom) nextfom))
>                                      ((yas--mirror-p fom)
>                                       (setf (yas--mirror-next fom) nextfom))
3025,3030c3695,3702
<                                       (setf (yas/exit-next fom) nextfom))))
<          (yas/compare-fom-begs (fom1 fom2)
<                                (> (yas/fom-start fom2) (yas/fom-start fom1)))
<          (yas/link-foms (fom1 fom2)
<                         (yas/fom-set-next-fom fom1 fom2)))
<     ;; make some yas/field, yas/mirror and yas/exit soup
---
>                                       (setf (yas--exit-next fom) nextfom))))
>          (yas--compare-fom-begs (fom1 fom2)
>                                (if (= (yas--fom-start fom2) (yas--fom-start fom1))
>                                    (yas--mirror-p fom2)
>                                  (>= (yas--fom-start fom2) (yas--fom-start fom1))))
>          (yas--link-foms (fom1 fom2)
>                         (yas--fom-set-next-fom fom1 fom2)))
>     ;; make some yas--field, yas--mirror and yas--exit soup
3032,3034c3704,3706
<       (when (yas/snippet-exit snippet)
<         (push (yas/snippet-exit snippet) soup))
<       (dolist (field (yas/snippet-fields snippet))
---
>       (when (yas--snippet-exit snippet)
>         (push (yas--snippet-exit snippet) soup))
>       (dolist (field (yas--snippet-fields snippet))
3036c3708
<         (dolist (mirror (yas/field-mirrors field))
---
>         (dolist (mirror (yas--field-mirrors field))
3040c3712
<                   #'yas/compare-fom-begs))
---
>                   #'yas--compare-fom-begs))
3042c3714,3731
<         (reduce #'yas/link-foms soup)))))
---
>         (reduce #'yas--link-foms soup)))))
> 
> (defun yas--calculate-mirrors-in-fields (snippet mirror)
>   "Attempt to assign a parent field of SNIPPET to the mirror MIRROR.
> 
> Use the tighest containing field if more than one field contains
> the mirror. Intended to be called *before* the dollar-regions are
> deleted."
>   (let ((min (point-min))
>         (max (point-max)))
>     (dolist (field (yas--snippet-fields snippet))
>       (when (and (<= (yas--field-start field) (yas--mirror-start mirror))
>                  (<= (yas--mirror-end mirror) (yas--field-end field))
>                (< min (yas--field-start field))
>                (< (yas--field-end field) max))
>           (setq min (yas--field-start field)
>                 max (yas--field-end field))
>           (setf (yas--mirror-parent-field mirror) field)))))
3044c3733
< (defun yas/advance-end-maybe (fom newend)
---
> (defun yas--advance-end-maybe (fom newend)
3049c3738
< * call `yas/advance-start-maybe' on FOM's next fom.
---
> * call `yas--advance-start-maybe' on FOM's next fom.
3051,3058c3740,3741
< * in case FOM is field call `yas/advance-end-maybe' on its parent
<   field"
<   (when (and fom (< (yas/fom-end fom) newend))
<     (set-marker (yas/fom-end fom) newend)
<     (yas/advance-start-maybe (yas/fom-next fom) newend)
<     (if (and (yas/field-p fom)
<              (yas/field-parent-field fom))
<         (yas/advance-end-maybe (yas/field-parent-field fom) newend))))
---
> * in case FOM is field call `yas--advance-end-maybe' on its parent
>   field
3060c3743,3755
< (defun yas/advance-start-maybe (fom newstart)
---
> Also, if FOM is an exit-marker, always call
> `yas--advance-start-maybe' on its next fom. This is beacuse
> exit-marker have identical start and end markers.
> 
> "
>   (cond ((and fom (< (yas--fom-end fom) newend))
>          (set-marker (yas--fom-end fom) newend)
>          (yas--advance-start-maybe (yas--fom-next fom) newend)
>          (yas--advance-end-of-parents-maybe (yas--fom-parent-field fom) newend))
>         ((yas--exit-p fom)
>          (yas--advance-start-maybe (yas--fom-next fom) newend))))
> 
> (defun yas--advance-start-maybe (fom newstart)
3063,3066c3758,3771
< If it does, also call `yas/advance-end-maybe' on FOM."
<   (when (and fom (< (yas/fom-start fom) newstart))
<     (set-marker (yas/fom-start fom) newstart)
<     (yas/advance-end-maybe fom newstart)))
---
> If it does, also call `yas--advance-end-maybe' on FOM."
>   (when (and fom (< (yas--fom-start fom) newstart))
>     (set-marker (yas--fom-start fom) newstart)
>     (yas--advance-end-maybe fom newstart)))
> 
> (defun yas--advance-end-of-parents-maybe (field newend)
>   "Like `yas--advance-end-maybe' but for parent fields.
> 
> Only works for fields and doesn't care about the start of the
> next FOM. Works its way up recursively for parents of parents."
>   (when (and field
>              (< (yas--field-end field) newend))
>     (set-marker (yas--field-end field) newend)
>     (yas--advance-end-of-parents-maybe (yas--field-parent-field field) newend)))
3068c3773
< (defvar yas/dollar-regions nil
---
> (defvar yas--dollar-regions nil
3072c3777,3782
< (defun yas/snippet-parse-create (snippet)
---
> (defvar yas--backquote-markers-and-strings nil
>   "List of (MARKER . STRING) marking where the the values
>   from backquoted lisp expressions should be inserted at the end of
>   expansion" )
> 
> (defun yas--snippet-parse-create (snippet)
3078c3788
<     ;; Reset the yas/dollar-regions
---
>     ;; Reset the yas--dollar-regions
3080,3081c3790,3791
<     (setq yas/dollar-regions nil)
<     ;; protect escaped quote, backquotes and backslashes
---
>     (setq yas--dollar-regions nil)
>     ;; protect just the backquotes
3083c3793
<     (yas/protect-escapes nil '(?\\ ?` ?'))
---
>     (yas--protect-escapes nil '(?`))
3087,3089c3797,3798
<     (yas/replace-backquotes)
<     ;; protect escapes again since previous steps might have generated
<     ;; more characters needing escaping
---
>     (yas--save-backquotes)
>     ;; protect escaped characters
3091,3092c3800
<     (goto-char parse-start)
<     (yas/protect-escapes)
---
>     (yas--protect-escapes)
3096c3804
<     (yas/field-parse-create snippet)
---
>     (yas--field-parse-create snippet)
3100c3808
<     (yas/simple-mirror-parse-create snippet)
---
>     (yas--simple-mirror-parse-create snippet)
3104c3812
<     (yas/transform-mirror-parse-create snippet)
---
>     (yas--transform-mirror-parse-create snippet)
3107c3815
<     (yas/calculate-adjacencies snippet)
---
>     (yas--calculate-adjacencies snippet)
3110c3818,3821
<     (yas/delete-regions yas/dollar-regions)
---
>     (yas--delete-regions yas--dollar-regions)
>     ;; restore backquoted expression values
>     ;;
>     (yas--restore-backquotes)
3114c3825
<     (yas/restore-escapes)
---
>     (yas--restore-escapes)
3117c3828
<     (yas/update-mirrors snippet)
---
>     (yas--update-mirrors snippet)
3121c3832
<     (yas/indent snippet)))
---
>     (yas--indent snippet)))
3123c3834
< (defun yas/indent-according-to-mode (snippet-markers)
---
> (defun yas--indent-according-to-mode (snippet-markers)
3126c3837
<   ;; XXX: Here seems to be the indent problem:
---
>   ;;; Apropos indenting problems....
3128,3134c3839,3843
<   ;; `indent-according-to-mode' uses whatever
<   ;; `indent-line-function' is available. Some
<   ;; implementations of these functions delete text
<   ;; before they insert. If there happens to be a marker
<   ;; just after the text being deleted, the insertion
<   ;; actually happens  after the marker, which misplaces
<   ;; it.
---
>   ;; `indent-according-to-mode' uses whatever `indent-line-function'
>   ;; is available. Some implementations of these functions delete text
>   ;; before they insert. If there happens to be a marker just after
>   ;; the text being deleted, the insertion actually happens after the
>   ;; marker, which misplaces it.
3136,3137c3845,3846
<   ;; This would also happen if we had used overlays with
<   ;; the `front-advance' property set to nil.
---
>   ;; This would also happen if we had used overlays with the
>   ;; `front-advance' property set to nil.
3141c3850
<   ;; (i.e. at `yas/real-line-beginning'. After indentation takes place
---
>   ;; (i.e. at `yas--real-line-beginning'. After indentation takes place
3146c3855
<   (goto-char (yas/real-line-beginning))
---
>   (goto-char (yas--real-line-beginning))
3154c3863
<         (error (message "[yas] warning: yas/indent-according-to-mode habing problems running %s" indent-line-function)
---
>         (error (yas--message 3 "Warning: `yas--indent-according-to-mode' having problems running %s" indent-line-function)
3160,3161c3869,3871
< (defun yas/indent (snippet)
<   (let ((snippet-markers (yas/collect-snippet-markers snippet)))
---
> (defvar yas--indent-original-column nil)
> (defun yas--indent (snippet)
>   (let ((snippet-markers (yas--collect-snippet-markers snippet)))
3166,3167c3876,3877
<         (when (not (eq yas/indent-line 'auto))
<           (yas/indent-according-to-mode snippet-markers))))
---
>         (when (not (eq yas-indent-line 'auto))
>           (yas--indent-according-to-mode snippet-markers))))
3170c3880
<       (cond ((eq yas/indent-line 'fixed)
---
>       (cond ((eq yas-indent-line 'fixed)
3173,3174c3883,3884
<                (indent-to-column column)))
<             ((eq yas/indent-line 'auto)
---
>                (indent-to-column yas--indent-original-column)))
>             ((eq yas-indent-line 'auto)
3176c3886
<                    (indent-first-line-p yas/also-auto-indent-first-line))
---
>                    (indent-first-line-p yas-also-auto-indent-first-line))
3184c3894
<                  (yas/indent-according-to-mode snippet-markers))))
---
>                  (yas--indent-according-to-mode snippet-markers))))
3188c3898
< (defun yas/collect-snippet-markers (snippet)
---
> (defun yas--collect-snippet-markers (snippet)
3191,3197c3901,3907
<     (dolist (field (yas/snippet-fields snippet))
<       (push (yas/field-start field) markers)
<       (push (yas/field-end field) markers)
<       (dolist (mirror (yas/field-mirrors field))
<         (push (yas/mirror-start mirror) markers)
<         (push (yas/mirror-end mirror) markers)))
<     (let ((snippet-exit (yas/snippet-exit snippet)))
---
>     (dolist (field (yas--snippet-fields snippet))
>       (push (yas--field-start field) markers)
>       (push (yas--field-end field) markers)
>       (dolist (mirror (yas--field-mirrors field))
>         (push (yas--mirror-start mirror) markers)
>         (push (yas--mirror-end mirror) markers)))
>     (let ((snippet-exit (yas--snippet-exit snippet)))
3199,3200c3909,3910
<                  (marker-buffer (yas/exit-marker snippet-exit)))
<         (push (yas/exit-marker snippet-exit) markers)))
---
>                  (marker-buffer (yas--exit-marker snippet-exit)))
>         (push (yas--exit-marker snippet-exit) markers)))
3203c3913
< (defun yas/real-line-beginning ()
---
> (defun yas--real-line-beginning ()
3212c3922
< (defun yas/escape-string (escaped)
---
> (defun yas--escape-string (escaped)
3215c3925
< (defun yas/protect-escapes (&optional text escaped)
---
> (defun yas--protect-escapes (&optional text escaped)
3223,3224c3933,3934
<                     (yas/replace-all (concat "\\" (char-to-string escaped))
<                                      (yas/escape-string escaped)
---
>                     (yas--replace-all (concat "\\" (char-to-string escaped))
>                                      (yas--escape-string escaped)
3226c3936
<           (or escaped yas/escaped-characters))
---
>           (or escaped yas--escaped-characters))
3229c3939
< (defun yas/restore-escapes (&optional text escaped)
---
> (defun yas--restore-escapes (&optional text escaped)
3237c3947
<                     (yas/replace-all (yas/escape-string escaped)
---
>                     (yas--replace-all (yas--escape-string escaped)
3240c3950
<           (or escaped yas/escaped-characters))
---
>           (or escaped yas--escaped-characters))
3243,3250c3953,3980
< (defun yas/replace-backquotes ()
<   "Replace all the \"`(lisp-expression)`\"-style expression
<   with their evaluated value"
<   (while (re-search-forward yas/backquote-lisp-expression-regexp nil t)
<     (let ((transformed (yas/read-and-eval-string (yas/restore-escapes (match-string 1)))))
<       (goto-char (match-end 0))
<       (when transformed (insert transformed))
<       (delete-region (match-beginning 0) (match-end 0)))))
---
> (defun yas--save-backquotes ()
>   "Save all the \"`(lisp-expression)`\"-style expression
> with their evaluated value into `yas--backquote-markers-and-strings'"
>   (while (re-search-forward yas--backquote-lisp-expression-regexp nil t)
>     (let ((current-string (match-string-no-properties 1)) transformed)
>       (delete-region (match-beginning 0) (match-end 0))
>       (setq transformed (yas--eval-lisp (yas--read-lisp (yas--restore-escapes current-string '(?`)))))
>       (goto-char (match-beginning 0))
>       (when transformed
>         (let ((marker (make-marker)))
>           (insert "Y") ;; quite horrendous, I love it :)
>           (set-marker marker (point))
>           (insert "Y")
>           (push (cons marker transformed) yas--backquote-markers-and-strings))))))
> 
> (defun yas--restore-backquotes ()
>   "Replace all the markers in
> `yas--backquote-markers-and-strings' with their values"
>   (while yas--backquote-markers-and-strings
>     (let* ((marker-and-string (pop yas--backquote-markers-and-strings))
>            (marker (car marker-and-string))
>            (string (cdr marker-and-string)))
>       (save-excursion
>         (goto-char marker)
>         (delete-char -1)
>         (insert string)
>         (delete-char 1)
>         (set-marker marker nil)))))
3252c3982
< (defun yas/scan-sexps (from count)
---
> (defun yas--scan-sexps (from count)
3259c3989
< (defun yas/make-marker (pos)
---
> (defun yas--make-marker (pos)
3265c3995
< (defun yas/field-parse-create (snippet &optional parent-field)
---
> (defun yas--field-parse-create (snippet &optional parent-field)
3273c4003
<   this is caught with the curiously named `yas/multi-dollar-lisp-expression-regexp'
---
>   this is caught with the curiously named `yas--multi-dollar-lisp-expression-regexp'
3280,3281c4010,4011
<     (while (re-search-forward yas/field-regexp nil t)
<       (let* ((real-match-end-0 (yas/scan-sexps (1+ (match-beginning 0)) 1))
---
>     (while (re-search-forward yas--field-regexp nil t)
>       (let* ((real-match-end-0 (yas--scan-sexps (1+ (match-beginning 0)) 1))
3292,3295c4022,4026
<                                    (not (and number (zerop number)))
<                                    (yas/make-field number
<                                                    (yas/make-marker (match-beginning 2))
<                                                    (yas/make-marker (1- real-match-end-0))
---
>                                    ;; allow ${0: some exit text}
>                                    ;; (not (and number (zerop number)))
>                                    (yas--make-field number
>                                                    (yas--make-marker (match-beginning 2))
>                                                    (yas--make-marker (1- real-match-end-0))
3300c4031
<                 yas/dollar-regions)
---
>                 yas--dollar-regions)
3302,3303c4033,4034
<                 yas/dollar-regions)
<           (push brand-new-field (yas/snippet-fields snippet))
---
>                 yas--dollar-regions)
>           (push brand-new-field (yas--snippet-fields snippet))
3306c4037
<               (narrow-to-region (yas/field-start brand-new-field) (yas/field-end brand-new-field))
---
>               (narrow-to-region (yas--field-start brand-new-field) (yas--field-end brand-new-field))
3308c4039
<               (yas/field-parse-create snippet brand-new-field)))))))
---
>               (yas--field-parse-create snippet brand-new-field)))))))
3310c4041
<   ;; `yas/multi-dollar-lisp-expression-regexp'. THis is used for
---
>   ;; `yas--multi-dollar-lisp-expression-regexp'. THis is used for
3312c4043
<   ;; 
---
>   ;;
3315,3319c4046,4056
<       (while (re-search-forward yas/multi-dollar-lisp-expression-regexp nil t)
<         (let* ((real-match-end-1 (yas/scan-sexps (match-beginning 1) 1)))
<           ;; commit the primary field transformation if we don't find
<           ;; it in yas/dollar-regions (a subnested field) might have
<           ;; already caught it.
---
>       (while (re-search-forward yas--multi-dollar-lisp-expression-regexp nil t)
>         (let* ((real-match-end-1 (yas--scan-sexps (match-beginning 1) 1)))
>           ;; commit the primary field transformation if:
>           ;;
>           ;; 1. we don't find it in yas--dollar-regions (a subnested
>           ;; field) might have already caught it.
>           ;;
>           ;; 2. we really make sure we have either two '$' or some
>           ;; text and a '$' after the colon ':'. This is a FIXME: work
>           ;; my regular expressions and end these ugly hacks.
>           ;;
3323c4060,4062
<                                   yas/dollar-regions)))
---
>                                   yas--dollar-regions))
>                      (not (eq ?:
>                               (char-before (1- (match-beginning 1))))))
3326c4065,4066
<               (setf (yas/field-transform parent-field) (yas/restore-escapes lisp-expression-string)))
---
>               (setf (yas--field-transform parent-field)
>                     (yas--read-lisp (yas--restore-escapes lisp-expression-string))))
3328c4068
<                   yas/dollar-regions)))))))
---
>                   yas--dollar-regions)))))))
3330c4070
< (defun yas/transform-mirror-parse-create (snippet)
---
> (defun yas--transform-mirror-parse-create (snippet)
3332,3333c4072,4073
<   (while (re-search-forward yas/transform-mirror-regexp nil t)
<     (let* ((real-match-end-0 (yas/scan-sexps (1+ (match-beginning 0)) 1))
---
>   (while (re-search-forward yas--transform-mirror-regexp nil t)
>     (let* ((real-match-end-0 (yas--scan-sexps (1+ (match-beginning 0)) 1))
3337,3350c4077,4095
<                        (yas/snippet-find-field snippet number))))
<       (when (and real-match-end-0
<                  field)
<         (push (yas/make-mirror (yas/make-marker (match-beginning 0))
<                                (yas/make-marker (match-beginning 0))
<                                (yas/restore-escapes
<                                 (buffer-substring-no-properties (match-beginning 2)
<                                                                 (1- real-match-end-0))))
<               (yas/field-mirrors field))
<         (push (cons (match-beginning 0) real-match-end-0) yas/dollar-regions)))))
< 
< (defun yas/simple-mirror-parse-create (snippet)
<   "Parse the simple \"$n\" mirrors and the exit-marker."
<   (while (re-search-forward yas/simple-mirror-regexp nil t)
---
>                        (yas--snippet-find-field snippet number)))
>            (brand-new-mirror
>             (and real-match-end-0
>                  field
>                  (yas--make-mirror (yas--make-marker (match-beginning 0))
>                                   (yas--make-marker (match-beginning 0))
>                                   (yas--read-lisp
>                                    (yas--restore-escapes
>                                     (buffer-substring-no-properties (match-beginning 2)
>                                                                     (1- real-match-end-0))))))))
>       (when brand-new-mirror
>         (push brand-new-mirror
>               (yas--field-mirrors field))
>         (yas--calculate-mirrors-in-fields snippet brand-new-mirror)
>         (push (cons (match-beginning 0) real-match-end-0) yas--dollar-regions)))))
> 
> (defun yas--simple-mirror-parse-create (snippet)
>   "Parse the simple \"$n\" fields/mirrors/exitmarkers."
>   (while (re-search-forward yas--simple-mirror-regexp nil t)
3354,3355c4099,4100
<              (setf (yas/snippet-exit snippet)
<                    (yas/make-exit (yas/make-marker (match-end 0))))
---
>              (setf (yas--snippet-exit snippet)
>                    (yas--make-exit (yas--make-marker (match-end 0))))
3358,3361c4103,4106
<                (when yas/wrap-around-region
<                  (cond (yas/selected-text
<                         (insert yas/selected-text))
<                        ((and (eq yas/wrap-around-region 'cua)
---
>                (when yas-wrap-around-region
>                  (cond (yas-selected-text
>                         (insert yas-selected-text))
>                        ((and (eq yas-wrap-around-region 'cua)
3366,3367c4111,4112
<                (push (cons (point) (yas/exit-marker (yas/snippet-exit snippet)))
<                      yas/dollar-regions)))
---
>                (push (cons (point) (yas--exit-marker (yas--snippet-exit snippet)))
>                      yas--dollar-regions)))
3369c4114
<              (let ((field (yas/snippet-find-field snippet number)))
---
>              (let ((field (yas--snippet-find-field snippet number)))
3371,3377c4116,4125
<                    (push (yas/make-mirror (yas/make-marker (match-beginning 0))
<                                           (yas/make-marker (match-beginning 0))
<                                           nil)
<                          (yas/field-mirrors field))
<                  (push (yas/make-field number
<                                        (yas/make-marker (match-beginning 0))
<                                        (yas/make-marker (match-beginning 0))
---
>                    (let ((brand-new-mirror (yas--make-mirror
>                                             (yas--make-marker (match-beginning 0))
>                                             (yas--make-marker (match-beginning 0))
>                                             nil)))
>                      (push brand-new-mirror
>                            (yas--field-mirrors field))
>                      (yas--calculate-mirrors-in-fields snippet brand-new-mirror))
>                  (push (yas--make-field number
>                                        (yas--make-marker (match-beginning 0))
>                                        (yas--make-marker (match-beginning 0))
3379c4127
<                        (yas/snippet-fields snippet))))
---
>                        (yas--snippet-fields snippet))))
3381c4129
<                    yas/dollar-regions))))))
---
>                    yas--dollar-regions))))))
3383c4131
< (defun yas/delete-regions (regions)
---
> (defun yas--delete-regions (regions)
3391c4139
< (defun yas/update-mirrors (snippet)
---
> (defun yas--update-mirrors (snippet)
3394,3398c4142,4162
<     (dolist (field (yas/snippet-fields snippet))
<       (dolist (mirror (yas/field-mirrors field))
<         ;; stacked expansion: I added an `inhibit-modification-hooks'
<         ;; here, for safety, may need to remove if we the mechanism is
<         ;; altered.
---
>     (dolist (field-and-mirror (sort
>                                ;; make a list of ((F1 . M1) (F1 . M2) (F2 . M3) (F2 . M4) ...)
>                                ;; where F is the field that M is mirroring
>                                ;;
>                                (mapcan #'(lambda (field)
>                                            (mapcar #'(lambda (mirror)
>                                                        (cons field mirror))
>                                                    (yas--field-mirrors field)))
>                                        (yas--snippet-fields snippet))
>                                ;; then sort this list so that entries with mirrors with parent
>                                ;; fields appear before. This was important for fixing #290, and
>                                ;; luckily also handles the case where a mirror in a field causes
>                                ;; another mirror to need reupdating
>                                ;;
>                                #'(lambda (field-and-mirror1 field-and-mirror2)
>                                    (yas--mirror-parent-field (cdr field-and-mirror1)))))
>       (let* ((field (car field-and-mirror))
>              (mirror (cdr field-and-mirror))
>              (parent-field (yas--mirror-parent-field mirror)))
>         ;; before updating a mirror with a parent-field, maybe advance
>         ;; its start (#290)
3400,3407c4164,4174
<         (let ((inhibit-modification-hooks t))
<           (yas/mirror-update-display mirror field)
<           ;; `yas/place-overlays' is needed if the active field and
<           ;; protected overlays have been changed because of insertions
<           ;; in `yas/mirror-update-display'
<           ;;
<           (when (eq field (yas/snippet-active-field snippet))
<             (yas/place-overlays snippet field)))))))
---
>         (when parent-field
>           (yas--advance-start-maybe mirror (yas--fom-start parent-field)))
>         ;; update this mirror
>         ;;
>         (yas--mirror-update-display mirror field)
>         ;; `yas--place-overlays' is needed if the active field and
>         ;; protected overlays have been changed because of insertions
>         ;; in `yas--mirror-update-display'
>         ;;
>         (when (eq field (yas--snippet-active-field snippet))
>           (yas--place-overlays snippet field))))))
3409c4176
< (defun yas/mirror-update-display (mirror field)
---
> (defun yas--mirror-update-display (mirror field)
3411,3412c4178,4183
<   (let ((reflection (or (yas/apply-transform mirror field)
<                         (yas/field-text-for-display field))))
---
> 
>   (let* ((mirror-parent-field (yas--mirror-parent-field mirror))
>          (reflection (and (not (and mirror-parent-field
>                                     (yas--field-modified-p mirror-parent-field)))
>                           (or (yas--apply-transform mirror field 'empty-on-nil)
>                               (yas--field-text-for-display field)))))
3414,3427c4185,4201
<                (not (string= reflection (buffer-substring-no-properties (yas/mirror-start mirror)
<                                                                         (yas/mirror-end mirror)))))
<       (goto-char (yas/mirror-start mirror))
<       (insert reflection)
<       (if (> (yas/mirror-end mirror) (point))
<           (delete-region (point) (yas/mirror-end mirror))
<         (set-marker (yas/mirror-end mirror) (point))
<         (yas/advance-start-maybe (yas/mirror-next mirror) (point))))))
< 
< (defun yas/field-update-display (field snippet)
<   "Much like `yas/mirror-update-display', but for fields"
<   (when (yas/field-transform field)
<     (let ((inhibit-modification-hooks t)
<           (transformed (yas/apply-transform field field))
---
>                (not (string= reflection (buffer-substring-no-properties (yas--mirror-start mirror)
>                                                                         (yas--mirror-end mirror)))))
>       (goto-char (yas--mirror-start mirror))
>       (yas--inhibit-overlay-hooks
>         (insert reflection))
>       (if (> (yas--mirror-end mirror) (point))
>           (delete-region (point) (yas--mirror-end mirror))
>         (set-marker (yas--mirror-end mirror) (point))
>         (yas--advance-start-maybe (yas--mirror-next mirror) (point))
>         ;; super-special advance
>         (yas--advance-end-of-parents-maybe mirror-parent-field (point))))))
> 
> (defun yas--field-update-display (field snippet)
>   "Much like `yas--mirror-update-display', but for fields"
>   (when (yas--field-transform field)
>     (let ((transformed (and (not (eq (yas--field-number field) 0))
>                             (yas--apply-transform field field)))
3430,3439c4204,4214
<                  (not (string= transformed (buffer-substring-no-properties (yas/field-start field)
<                                                                            (yas/field-end field)))))
<         (setf (yas/field-modified-p field) t)
<         (goto-char (yas/field-start field))
<         (insert transformed)
<         (if (> (yas/field-end field) (point))
<             (delete-region (point) (yas/field-end field))
<           (set-marker (yas/field-end field) (point))
<           (yas/advance-start-maybe (yas/field-next field) (point)))
<         t))))
---
>                  (not (string= transformed (buffer-substring-no-properties (yas--field-start field)
>                                                                            (yas--field-end field)))))
>         (setf (yas--field-modified-p field) t)
>         (goto-char (yas--field-start field))
>         (yas--inhibit-overlay-hooks
>           (insert transformed)
>           (if (> (yas--field-end field) (point))
>               (delete-region (point) (yas--field-end field))
>             (set-marker (yas--field-end field) (point))
>             (yas--advance-start-maybe (yas--field-next field) (point)))
>           t)))))
3442,3445c4217
< ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
< ;; Pre- and post-command hooks
< ;;
< (defun yas/pre-command-handler () )
---
> ;;; Post-command hook:
3447c4219
< (defun yas/post-command-handler ()
---
> (defun yas--post-command-handler ()
3449,3451c4221,4223
<   (cond (yas/protection-violation
<          (goto-char yas/protection-violation)
<          (setq yas/protection-violation nil))
---
>   (cond (yas--protection-violation
>          (goto-char yas--protection-violation)
>          (setq yas--protection-violation nil))
3457c4229
<          (let* ((snippet (car (yas/snippets-at-point)))
---
>          (let* ((snippet (car (yas--snippets-at-point)))
3460c4232
<                                                     (yas/field-probably-deleted-p snippet field))
---
>                                                     (yas--field-probably-deleted-p snippet field))
3462,3463c4234,4235
<                                                         (cons (yas/snippet-active-field snippet)
<                                                               (yas/snippet-fields snippet)))))))
---
>                                                         (cons (yas--snippet-active-field snippet)
>                                                               (yas--snippet-fields snippet)))))))
3465,3473c4237,4243
<              (yas/move-to-field snippet target-field))))
<         ((not (yas/undo-in-progress))
<          ;; When not in an undo, check if we must commit the snippet (use exited it).
<          (yas/check-commit-snippet))))
< 
< ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
< ;; Debug functions.  Use (or change) at will whenever needed.
< ;;
< ;; some useful debug code for looking up snippet tables
---
>              (yas--move-to-field snippet target-field))))
>         ((not (yas--undo-in-progress))
>          ;; When not in an undo, check if we must commit the snippet
>          ;; (user exited it).
>          (yas--check-commit-snippet))))
> 
> ;;; Fancy docs:
3475,3480c4245,4246
< ;; (insert (pp
< ;; (let ((shit))
< ;;   (maphash #'(lambda (k v)
< ;;             (push k shit))
< ;;         (yas/snippet-table-hash (gethash 'ruby-mode yas/snippet-tables)))
< ;;   shit)))
---
> ;; The docstrings for some functions are generated dynamically
> ;; depending on the context.
3481a4248,4307
> (put 'yas-expand  'function-documentation
>      '(yas--expand-from-trigger-key-doc))
> (defun yas--expand-from-trigger-key-doc ()
>   "A doc synthethizer for `yas--expand-from-trigger-key-doc'."
>   (let ((fallback-description
>          (cond ((eq yas-fallback-behavior 'call-other-command)
>                 (let* ((yas-minor-mode nil)
>                        (fallback (key-binding (read-kbd-macro (yas--trigger-key-for-fallback)))))
>                   (or (and fallback
>                            (format " call command `%s'." (pp-to-string fallback)))
>                       " do nothing.")))
>                ((eq yas-fallback-behavior 'return-nil)
>                 ", do nothing.")
>                (t
>                 ", defer to `yas--fallback-behaviour' :-)"))))
>     (concat "Expand a snippet before point. If no snippet
> expansion is possible,"
>             fallback-description
>             "\n\nOptional argument FIELD is for non-interactive use and is an
> object satisfying `yas--field-p' to restrict the expansion to.")))
> 
> (put 'yas-expand-from-keymap  'function-documentation '(yas--expand-from-keymap-doc))
> (defun yas--expand-from-keymap-doc ()
>   "A doc synthethizer for `yas--expand-from-keymap-doc'."
>   (add-hook 'temp-buffer-show-hook 'yas--snippet-description-finish-runonce)
>   (concat "Expand/run snippets from keymaps, possibly falling back to original binding.\n"
>           (when (eq this-command 'describe-key)
>             (let* ((vec (this-single-command-keys))
>                    (templates (mapcan #'(lambda (table)
>                                           (yas--fetch table vec))
>                                       (yas--get-snippet-tables)))
>                    (yas--direct-keymaps nil)
>                    (fallback (key-binding vec)))
>               (concat "In this case, "
>                       (when templates
>                         (concat "these snippets are bound to this key:\n"
>                                 (yas--template-pretty-list templates)
>                                 "\n\nIf none of these expands, "))
>                       (or (and fallback
>                                (format "fallback `%s' will be called." (pp-to-string fallback)))
>                           "no fallback keybinding is called."))))))
> 
> (defun yas--template-pretty-list (templates)
>   (let ((acc)
>         (yas-buffer-local-condition 'always))
>     (dolist (plate templates)
>       (setq acc (concat acc "\n*) "
>                         (propertize (concat "\\\\snippet `" (car plate) "'")
>                                     'yasnippet (cdr plate)))))
>     acc))
> 
> (define-button-type 'help-snippet-def
>   :supertype 'help-xref
>   'help-function (lambda (template) (yas--visit-snippet-file-1 template))
>   'help-echo (purecopy "mouse-2, RET: find snippets's definition"))
> 
> (defun yas--snippet-description-finish-runonce ()
>   "Final adjustments for the help buffer when snippets are concerned."
>   (yas--create-snippet-xrefs)
>   (remove-hook 'temp-buffer-show-hook 'yas--snippet-description-finish-runonce))
3483,3507c4309,4330
< (defun yas/debug-tables ()
<   (interactive)
<   (with-output-to-temp-buffer "*YASnippet tables*"
<     (dolist (symbol (remove nil (append (list major-mode)
<                                         (if (listp yas/mode-symbol)
<                                             yas/mode-symbol
<                                           (list yas/mode-symbol)))))
<       (princ (format "Snippet table hash keys for %s:\n\n" symbol))
<       (let ((keys))
<         (maphash #'(lambda (k v)
<                      (push k keys))
<                  (yas/snippet-table-hash (gethash symbol yas/snippet-tables)))
<         (princ keys))
< 
<       (princ (format "Keymap for  %s:\n\n" symbol))
<       (princ (gethash symbol yas/menu-table)))))
< 
< (defun yas/debug-snippet-vars ()
<   "Debug snippets, fields, mirrors and the `buffer-undo-list'."
<   (interactive)
<   (with-output-to-temp-buffer "*YASnippet trace*"
<     (princ "Interesting YASnippet vars: \n\n")
< 
<     (princ (format "\nPost command hook: %s\n" post-command-hook))
<     (princ (format "\nPre  command hook: %s\n" pre-command-hook))
---
> (defun yas--create-snippet-xrefs ()
>   (save-excursion
>     (goto-char (point-min))
>     (while (search-forward-regexp "\\\\\\\\snippet[ \s\t]+`\\([^']+\\)'" nil t)
>       (let ((template (get-text-property (match-beginning 1)
>                                          'yasnippet)))
>         (when template
>           (help-xref-button 1 'help-snippet-def template)
>           (kill-region (match-end 1) (match-end 0))
>           (kill-region (match-beginning 0) (match-beginning 1)))))))
> 
> (defun yas--expand-uuid (mode-symbol uuid &optional start end expand-env)
>   "Expand a snippet registered in MODE-SYMBOL's table with UUID.
> 
> Remaining args as in `yas-expand-snippet'."
>   (let* ((table (gethash mode-symbol yas--tables))
>          (yas--current-template (and table
>                                     (gethash uuid (yas--table-uuidhash table)))))
>     (when yas--current-template
>       (yas-expand-snippet (yas--template-content yas--current-template)))))
> 
> ;;; Utils
3509,3566c4332,4333
<     (princ (format "%s live snippets in total\n" (length (yas/snippets-at-point (quote all-snippets)))))
<     (princ (format "%s overlays in buffer:\n\n" (length (overlays-in (point-min) (point-max)))))
<     (princ (format "%s live snippets at point:\n\n" (length (yas/snippets-at-point))))
< 
< 
<     (dolist (snippet (yas/snippets-at-point))
<       (princ (format "\tsid: %d control overlay from %d to %d\n"
<                      (yas/snippet-id snippet)
<                      (overlay-start (yas/snippet-control-overlay snippet))
<                      (overlay-end (yas/snippet-control-overlay snippet))))
<       (princ (format "\tactive field: %d from %s to %s covering \"%s\"\n"
<                      (yas/field-number (yas/snippet-active-field snippet))
<                      (marker-position (yas/field-start (yas/snippet-active-field snippet)))
<                      (marker-position (yas/field-end (yas/snippet-active-field snippet)))
<                      (buffer-substring-no-properties (yas/field-start (yas/snippet-active-field snippet)) (yas/field-end (yas/snippet-active-field snippet)))))
<       (when (yas/snippet-exit snippet)
<         (princ (format "\tsnippet-exit: at %s next: %s\n"
<                        (yas/exit-marker (yas/snippet-exit snippet))
<                        (yas/exit-next (yas/snippet-exit snippet)))))
<       (dolist (field (yas/snippet-fields snippet))
<         (princ (format "\tfield: %d from %s to %s covering \"%s\" next: %s\n"
<                        (yas/field-number field)
<                        (marker-position (yas/field-start field))
<                        (marker-position (yas/field-end field))
<                        (buffer-substring-no-properties (yas/field-start field) (yas/field-end field))
<                        (yas/debug-format-fom-concise (yas/field-next field))))
<         (dolist (mirror (yas/field-mirrors field))
<           (princ (format "\t\tmirror: from %s to %s covering \"%s\" next: %s\n"
<                          (marker-position (yas/mirror-start mirror))
<                          (marker-position (yas/mirror-end mirror))
<                          (buffer-substring-no-properties (yas/mirror-start mirror) (yas/mirror-end mirror))
<                          (yas/debug-format-fom-concise (yas/mirror-next mirror)))))))
< 
<     (princ (format "\nUndo is %s and point-max is %s.\n"
<                    (if (eq buffer-undo-list t)
<                        "DISABLED"
<                      "ENABLED")
<                    (point-max)))
<     (unless (eq buffer-undo-list t)
<       (princ (format "Undpolist has %s elements. First 10 elements follow:\n" (length buffer-undo-list)))
<       (let ((first-ten (subseq buffer-undo-list 0 19)))
<         (dolist (undo-elem first-ten)
<           (princ (format "%2s:  %s\n" (position undo-elem first-ten) (truncate-string-to-width (format "%s" undo-elem) 70))))))))
< 
< (defun yas/debug-format-fom-concise (fom)
<   (when fom
<     (cond ((yas/field-p fom)
<            (format "field %d from %d to %d"
<                    (yas/field-number fom)
<                    (marker-position (yas/field-start fom))
<                    (marker-position (yas/field-end fom))))
<           ((yas/mirror-p fom)
<            (format "mirror from %d to %d"
<                    (marker-position (yas/mirror-start fom))
<                    (marker-position (yas/mirror-end fom))))
<           (t
<            (format "snippet exit at %d"
<                    (marker-position (yas/fom-start fom)))))))
---
> (defvar yas-verbosity 4
>   "Log level for `yas--message' 4 means trace most anything, 0 means nothing.")
3567a4335,4337
> (defun yas--message (level message &rest args)
>   (when (> yas-verbosity level)
>     (message (apply #'yas--format message args))))
3569,3576c4339,4340
< (defun yas/exterminate-package ()
<   (interactive)
<   (yas/global-mode -1)
<   (yas/minor-mode -1)
<   (yas/kill-snippet-keybindings)
<   (mapatoms #'(lambda (atom)
<                 (when (string-match "yas/" (symbol-name atom))
<                   (unintern atom)))))
---
> (defun yas--format (format-control &rest format-args)
>   (apply #'format (concat "[yas] " format-control) format-args))
3578,3604c4342,4358
< (defun yas/debug-test (&optional quiet)
<   (interactive "P")
<   (yas/load-directory (or (and (listp yas/root-directory)
<                                (first yas/root-directory))
<                           yas/root-directory
<                           "~/Source/yasnippet/snippets/"))
<   (set-buffer (switch-to-buffer "*YAS TEST*"))
<   (mapc #'yas/commit-snippet (yas/snippets-at-point 'all-snippets))
<   (erase-buffer)
<   (setq buffer-undo-list nil)
<   (setq undo-in-progress nil)
<   (snippet-mode)
<   (yas/minor-mode 1)
<   (let ((abbrev))
<     (setq abbrev "$f")
<     (insert abbrev))
<   (unless quiet
<     (add-hook 'post-command-hook 'yas/debug-snippet-vars 't 'local)))
< 
< 
< ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
< ;;; `locate-dominating-file' is added for compatibility in emacs < 23
< (unless (or (eq emacs-major-version 23)
<             (fboundp 'locate-dominating-file))
<   (defvar locate-dominating-stop-dir-regexp
<     "\\`\\(?:[\\/][\\/][^\\/]+[\\/]\\|/\\(?:net\\|afs\\|\\.\\.\\.\\)/\\)\\'"
<     "Regexp of directory names which stop the search in `locate-dominating-file'.
---
> 
> ;;; Some hacks:
> ;;
> ;; The functions
> ;;
> ;; `locate-dominating-file'
> ;; `region-active-p'
> ;;
> ;; added for compatibility in emacsen < 23
> (unless (>= emacs-major-version 23)
>   (unless (fboundp 'region-active-p)
>     (defun region-active-p ()  (and transient-mark-mode mark-active)))
> 
>   (unless (fboundp 'locate-dominating-file)
>     (defvar locate-dominating-stop-dir-regexp
>       "\\`\\(?:[\\/][\\/][^\\/]+[\\/]\\|/\\(?:net\\|afs\\|\\.\\.\\.\\)/\\)\\'"
>       "Regexp of directory names which stop the search in `locate-dominating-file'.
3612,3613c4366,4367
<   (defun locate-dominating-file (file name)
<     "Look up the directory hierarchy from FILE for a file named NAME.
---
>     (defun locate-dominating-file (file name)
>       "Look up the directory hierarchy from FILE for a file named NAME.
3616,3649c4370,4415
<     ;; We used to use the above locate-dominating-files code, but the
<     ;; directory-files call is very costly, so we're much better off doing
<     ;; multiple calls using the code in here.
<     ;;
<     ;; Represent /home/luser/foo as ~/foo so that we don't try to look for
<     ;; `name' in /home or in /.
<     (setq file (abbreviate-file-name file))
<     (let ((root nil)
<           (prev-file file)
<           ;; `user' is not initialized outside the loop because
<           ;; `file' may not exist, so we may have to walk up part of the
<           ;; hierarchy before we find the "initial UID".
<           (user nil)
<           try)
<       (while (not (or root
<                       (null file)
<                       ;; FIXME: Disabled this heuristic because it is sometimes
<                       ;; inappropriate.
<                       ;; As a heuristic, we stop looking up the hierarchy of
<                       ;; directories as soon as we find a directory belonging
<                       ;; to another user.  This should save us from looking in
<                       ;; things like /net and /afs.  This assumes that all the
<                       ;; files inside a project belong to the same user.
<                       ;; (let ((prev-user user))
<                       ;;   (setq user (nth 2 (file-attributes file)))
<                       ;;   (and prev-user (not (equal user prev-user))))
<                       (string-match locate-dominating-stop-dir-regexp file)))
<         (setq try (file-exists-p (expand-file-name name file)))
<         (cond (try (setq root file))
<               ((equal file (setq prev-file file
<                                  file (file-name-directory
<                                        (directory-file-name file))))
<                (setq file nil))))
<       root)))
---
>       ;; We used to use the above locate-dominating-files code, but the
>       ;; directory-files call is very costly, so we're much better off doing
>       ;; multiple calls using the code in here.
>       ;;
>       ;; Represent /home/luser/foo as ~/foo so that we don't try to look for
>       ;; `name' in /home or in /.
>       (setq file (abbreviate-file-name file))
>       (let ((root nil)
>             (prev-file file)
>             ;; `user' is not initialized outside the loop because
>             ;; `file' may not exist, so we may have to walk up part of the
>             ;; hierarchy before we find the "initial UUID".
>             (user nil)
>             try)
>         (while (not (or root
>                         (null file)
>                         ;; FIXME: Disabled this heuristic because it is sometimes
>                         ;; inappropriate.
>                         ;; As a heuristic, we stop looking up the hierarchy of
>                         ;; directories as soon as we find a directory belonging
>                         ;; to another user.  This should save us from looking in
>                         ;; things like /net and /afs.  This assumes that all the
>                         ;; files inside a project belong to the same user.
>                         ;; (let ((prev-user user))
>                         ;;   (setq user (nth 2 (file-attributes file)))
>                         ;;   (and prev-user (not (equal user prev-user))))
>                         (string-match locate-dominating-stop-dir-regexp file)))
>           (setq try (file-exists-p (expand-file-name name file)))
>           (cond (try (setq root file))
>                 ((equal file (setq prev-file file
>                                    file (file-name-directory
>                                          (directory-file-name file))))
>                  (setq file nil))))
>         root))))
> 
> ;; `c-neutralize-syntax-in-CPP` sometimes fires "End of Buffer" error
> ;; (when it execute forward-char) and interrupt the after change
> ;; hook. Thus prevent the insert-behind hook of yasnippet to be
> ;; invoked. Here's a way to reproduce it:
> 
> ;; # open a *new* Emacs.
> ;; # load yasnippet.
> ;; # open a *new* .cpp file.
> ;; # input "inc" and press TAB to expand the snippet.
> ;; # select the `#include <...>` snippet.
> ;; # type inside `<>`
3651,3658d4416
< (provide 'yasnippet)
< 
< ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
< ;; Monkey patching for other functions that's causing
< ;; problems to yasnippet. For details on why I patch
< ;; those functions, refer to
< ;;   http://code.google.com/p/yasnippet/wiki/MonkeyPatching
< ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
3660c4418
<   (around yas-mp/c-neutralize-syntax-in-CPP activate)
---
>   (around yas--mp/c-neutralize-syntax-in-CPP activate)
3672c4430
<                (define-key (symbol-value (make-local-variable 'yas/keymap))
---
>                (define-key (symbol-value (make-local-variable 'yas-keymap))
3673a4432,4560
> 
> ;;; Backward compatibility to to yasnippet <= 0.7
> (defvar yas--exported-syms '(;; `defcustom's
>                              ;;
>                              yas-snippet-dirs
>                              yas-prompt-functions
>                              yas-indent-line
>                              yas-also-auto-indent-first-line
>                              yas-snippet-revival
>                              yas-trigger-key
>                              yas-next-field-key
>                              yas-prev-field-key
>                              yas-skip-and-clear-key
>                              yas-triggers-in-field
>                              yas-fallback-behavior
>                              yas-choose-keys-first
>                              yas-choose-tables-first
>                              yas-use-menu
>                              yas-trigger-symbol
>                              yas-wrap-around-region
>                              yas-good-grace
>                              yas-visit-from-menu
>                              yas-expand-only-for-last-commands
>                              yas-field-highlight-face
> 
>                              ;; these vars can be customized as well
>                              ;;
>                              yas-keymap
>                              yas-verbosity
>                              yas-extra-modes
>                              yas-key-syntaxes
>                              yas-after-exit-snippet-hook
>                              yas-before-expand-snippet-hook
>                              yas-buffer-local-condition
> 
>                              ;; prompting functions
>                              ;;
>                              yas-x-prompt
>                              yas-ido-prompt
>                              yas-no-prompt
>                              yas-completing-prompt
>                              yas-dropdown-prompt
> 
>                              ;; interactive functions
>                              ;;
>                              yas-expand
>                              yas-minor-mode
>                              yas-global-mode
>                              yas-direct-keymaps-reload
>                              yas-minor-mode-on
>                              yas-load-directory
>                              yas-reload-all
>                              yas-compile-directory
>                              yas-recompile-all
>                              yas-about
>                              yas-expand-from-trigger-key
>                              yas-expand-from-keymap
>                              yas-insert-snippet
>                              yas-visit-snippet-file
>                              yas-new-snippet
>                              yas-load-snippet-buffer
>                              yas-tryout-snippet
>                              yas-describe-tables
>                              yas-next-field-or-maybe-expand
>                              yas-next-field
>                              yas-prev-field
>                              yas-abort-snippet
>                              yas-exit-snippet
>                              yas-exit-all-snippets
>                              yas-skip-and-clear-or-delete-char
> 
>                              ;; symbols that I "exported" for use
>                              ;; in snippets and hookage
>                              ;;
>                              yas-expand-snippet
>                              yas-define-snippets
>                              yas-define-menu
>                              yas-snippet-beg
>                              yas-snippet-end
>                              yas-modified-p
>                              yas-moving-away-p
>                              yas-text
>                              yas-substr
>                              yas-choose-value
>                              yas-key-to-value
>                              yas-throw
>                              yas-verify-value
>                              yas-field-value
>                              yas-text
>                              yas-selected-text
>                              yas-default-from-field
>                              yas-inside-string
>                              yas-unimplemented
>                              yas-define-condition-cache
>                              yas-hippie-try-expand
>                              yas-active-keys
> 
>                              ;; debug definitions
>                              ;; yas-debug-snippet-vars
>                              ;; yas-exterminate-package
>                              ;; yas-debug-test
> 
>                              ;; testing definitions
>                              ;; yas-should-expand
>                              ;; yas-should-not-expand
>                              ;; yas-mock-insert
>                              ;; yas-make-file-or-dirs
>                              ;; yas-variables
>                              ;; yas-saving-variables
>                              ;; yas-call-with-snippet-dirs
>                              ;; yas-with-snippet-dirs
> )
>   "Exported yassnippet symbols.
> 
> i.e. ones that I will try to keep in future yasnippet versions
> and ones that other elisp libraries can more or less safely rely
> upon.")
> 
> (defvar yas--dont-backport '(yas-active-keys)
>   "Exported symbols that don't map back to \"yas/*\" variants")
> 
> (dolist (sym (set-difference yas--exported-syms yas--dont-backport))
>   (let ((backported (intern (replace-regexp-in-string "^yas-" "yas/" (symbol-name sym)))))
>     (when (boundp sym)
>       (make-obsolete-variable backported sym "yasnippet 0.8")
>       (defvaralias backported sym))
>     (when (fboundp sym)
>       (make-obsolete backported sym "yasnippet 0.8")
>       (defalias backported sym))))
3674a4562,4563
> 
> (provide 'yasnippet-github)
3676a4566,4568
> ;; Local Variables:
> ;; coding: utf-8
> ;; End:
